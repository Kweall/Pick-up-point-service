// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

import (
	"context"
	"homework/internal/storage/postgres"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// FacadeMock implements mm_app.Facade
type FacadeMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAcceptReturn          func(ctx context.Context, clientID int64, orderID int64) (err error)
	funcAcceptReturnOrigin    string
	inspectFuncAcceptReturn   func(ctx context.Context, clientID int64, orderID int64)
	afterAcceptReturnCounter  uint64
	beforeAcceptReturnCounter uint64
	AcceptReturnMock          mFacadeMockAcceptReturn

	funcAddOrder          func(ctx context.Context, orderID int64, clientID int64, createdAt time.Time, expiredAt time.Time, weight float64, price int64, packaging string, additional_film string) (err error)
	funcAddOrderOrigin    string
	inspectFuncAddOrder   func(ctx context.Context, orderID int64, clientID int64, createdAt time.Time, expiredAt time.Time, weight float64, price int64, packaging string, additional_film string)
	afterAddOrderCounter  uint64
	beforeAddOrderCounter uint64
	AddOrderMock          mFacadeMockAddOrder

	funcCheckOrderStatus          func(ctx context.Context, orderID int64) (b1 bool, b2 bool, err error)
	funcCheckOrderStatusOrigin    string
	inspectFuncCheckOrderStatus   func(ctx context.Context, orderID int64)
	afterCheckOrderStatusCounter  uint64
	beforeCheckOrderStatusCounter uint64
	CheckOrderStatusMock          mFacadeMockCheckOrderStatus

	funcDeleteOrder          func(ctx context.Context, orderID int64) (err error)
	funcDeleteOrderOrigin    string
	inspectFuncDeleteOrder   func(ctx context.Context, orderID int64)
	afterDeleteOrderCounter  uint64
	beforeDeleteOrderCounter uint64
	DeleteOrderMock          mFacadeMockDeleteOrder

	funcGetOrders          func(ctx context.Context, clientID int64) (opa1 []*postgres.Order, err error)
	funcGetOrdersOrigin    string
	inspectFuncGetOrders   func(ctx context.Context, clientID int64)
	afterGetOrdersCounter  uint64
	beforeGetOrdersCounter uint64
	GetOrdersMock          mFacadeMockGetOrders

	funcGetOrdersByIDs          func(ctx context.Context, orderIDs []int64) (opa1 []*postgres.Order, err error)
	funcGetOrdersByIDsOrigin    string
	inspectFuncGetOrdersByIDs   func(ctx context.Context, orderIDs []int64)
	afterGetOrdersByIDsCounter  uint64
	beforeGetOrdersByIDsCounter uint64
	GetOrdersByIDsMock          mFacadeMockGetOrdersByIDs

	funcGetReturns          func(ctx context.Context) (opa1 []*postgres.Order, err error)
	funcGetReturnsOrigin    string
	inspectFuncGetReturns   func(ctx context.Context)
	afterGetReturnsCounter  uint64
	beforeGetReturnsCounter uint64
	GetReturnsMock          mFacadeMockGetReturns

	funcGiveOrders          func(ctx context.Context, orderIDs []int64) (err error)
	funcGiveOrdersOrigin    string
	inspectFuncGiveOrders   func(ctx context.Context, orderIDs []int64)
	afterGiveOrdersCounter  uint64
	beforeGiveOrdersCounter uint64
	GiveOrdersMock          mFacadeMockGiveOrders
}

// NewFacadeMock returns a mock for mm_app.Facade
func NewFacadeMock(t minimock.Tester) *FacadeMock {
	m := &FacadeMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcceptReturnMock = mFacadeMockAcceptReturn{mock: m}
	m.AcceptReturnMock.callArgs = []*FacadeMockAcceptReturnParams{}

	m.AddOrderMock = mFacadeMockAddOrder{mock: m}
	m.AddOrderMock.callArgs = []*FacadeMockAddOrderParams{}

	m.CheckOrderStatusMock = mFacadeMockCheckOrderStatus{mock: m}
	m.CheckOrderStatusMock.callArgs = []*FacadeMockCheckOrderStatusParams{}

	m.DeleteOrderMock = mFacadeMockDeleteOrder{mock: m}
	m.DeleteOrderMock.callArgs = []*FacadeMockDeleteOrderParams{}

	m.GetOrdersMock = mFacadeMockGetOrders{mock: m}
	m.GetOrdersMock.callArgs = []*FacadeMockGetOrdersParams{}

	m.GetOrdersByIDsMock = mFacadeMockGetOrdersByIDs{mock: m}
	m.GetOrdersByIDsMock.callArgs = []*FacadeMockGetOrdersByIDsParams{}

	m.GetReturnsMock = mFacadeMockGetReturns{mock: m}
	m.GetReturnsMock.callArgs = []*FacadeMockGetReturnsParams{}

	m.GiveOrdersMock = mFacadeMockGiveOrders{mock: m}
	m.GiveOrdersMock.callArgs = []*FacadeMockGiveOrdersParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mFacadeMockAcceptReturn struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockAcceptReturnExpectation
	expectations       []*FacadeMockAcceptReturnExpectation

	callArgs []*FacadeMockAcceptReturnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockAcceptReturnExpectation specifies expectation struct of the Facade.AcceptReturn
type FacadeMockAcceptReturnExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockAcceptReturnParams
	paramPtrs          *FacadeMockAcceptReturnParamPtrs
	expectationOrigins FacadeMockAcceptReturnExpectationOrigins
	results            *FacadeMockAcceptReturnResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockAcceptReturnParams contains parameters of the Facade.AcceptReturn
type FacadeMockAcceptReturnParams struct {
	ctx      context.Context
	clientID int64
	orderID  int64
}

// FacadeMockAcceptReturnParamPtrs contains pointers to parameters of the Facade.AcceptReturn
type FacadeMockAcceptReturnParamPtrs struct {
	ctx      *context.Context
	clientID *int64
	orderID  *int64
}

// FacadeMockAcceptReturnResults contains results of the Facade.AcceptReturn
type FacadeMockAcceptReturnResults struct {
	err error
}

// FacadeMockAcceptReturnOrigins contains origins of expectations of the Facade.AcceptReturn
type FacadeMockAcceptReturnExpectationOrigins struct {
	origin         string
	originCtx      string
	originClientID string
	originOrderID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptReturn *mFacadeMockAcceptReturn) Optional() *mFacadeMockAcceptReturn {
	mmAcceptReturn.optional = true
	return mmAcceptReturn
}

// Expect sets up expected params for Facade.AcceptReturn
func (mmAcceptReturn *mFacadeMockAcceptReturn) Expect(ctx context.Context, clientID int64, orderID int64) *mFacadeMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("FacadeMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &FacadeMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs != nil {
		mmAcceptReturn.mock.t.Fatalf("FacadeMock.AcceptReturn mock is already set by ExpectParams functions")
	}

	mmAcceptReturn.defaultExpectation.params = &FacadeMockAcceptReturnParams{ctx, clientID, orderID}
	mmAcceptReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptReturn.expectations {
		if minimock.Equal(e.params, mmAcceptReturn.defaultExpectation.params) {
			mmAcceptReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptReturn.defaultExpectation.params)
		}
	}

	return mmAcceptReturn
}

// ExpectCtxParam1 sets up expected param ctx for Facade.AcceptReturn
func (mmAcceptReturn *mFacadeMockAcceptReturn) ExpectCtxParam1(ctx context.Context) *mFacadeMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("FacadeMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &FacadeMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.params != nil {
		mmAcceptReturn.mock.t.Fatalf("FacadeMock.AcceptReturn mock is already set by Expect")
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs == nil {
		mmAcceptReturn.defaultExpectation.paramPtrs = &FacadeMockAcceptReturnParamPtrs{}
	}
	mmAcceptReturn.defaultExpectation.paramPtrs.ctx = &ctx
	mmAcceptReturn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAcceptReturn
}

// ExpectClientIDParam2 sets up expected param clientID for Facade.AcceptReturn
func (mmAcceptReturn *mFacadeMockAcceptReturn) ExpectClientIDParam2(clientID int64) *mFacadeMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("FacadeMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &FacadeMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.params != nil {
		mmAcceptReturn.mock.t.Fatalf("FacadeMock.AcceptReturn mock is already set by Expect")
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs == nil {
		mmAcceptReturn.defaultExpectation.paramPtrs = &FacadeMockAcceptReturnParamPtrs{}
	}
	mmAcceptReturn.defaultExpectation.paramPtrs.clientID = &clientID
	mmAcceptReturn.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmAcceptReturn
}

// ExpectOrderIDParam3 sets up expected param orderID for Facade.AcceptReturn
func (mmAcceptReturn *mFacadeMockAcceptReturn) ExpectOrderIDParam3(orderID int64) *mFacadeMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("FacadeMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &FacadeMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.params != nil {
		mmAcceptReturn.mock.t.Fatalf("FacadeMock.AcceptReturn mock is already set by Expect")
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs == nil {
		mmAcceptReturn.defaultExpectation.paramPtrs = &FacadeMockAcceptReturnParamPtrs{}
	}
	mmAcceptReturn.defaultExpectation.paramPtrs.orderID = &orderID
	mmAcceptReturn.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmAcceptReturn
}

// Inspect accepts an inspector function that has same arguments as the Facade.AcceptReturn
func (mmAcceptReturn *mFacadeMockAcceptReturn) Inspect(f func(ctx context.Context, clientID int64, orderID int64)) *mFacadeMockAcceptReturn {
	if mmAcceptReturn.mock.inspectFuncAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("Inspect function is already set for FacadeMock.AcceptReturn")
	}

	mmAcceptReturn.mock.inspectFuncAcceptReturn = f

	return mmAcceptReturn
}

// Return sets up results that will be returned by Facade.AcceptReturn
func (mmAcceptReturn *mFacadeMockAcceptReturn) Return(err error) *FacadeMock {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("FacadeMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &FacadeMockAcceptReturnExpectation{mock: mmAcceptReturn.mock}
	}
	mmAcceptReturn.defaultExpectation.results = &FacadeMockAcceptReturnResults{err}
	mmAcceptReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptReturn.mock
}

// Set uses given function f to mock the Facade.AcceptReturn method
func (mmAcceptReturn *mFacadeMockAcceptReturn) Set(f func(ctx context.Context, clientID int64, orderID int64) (err error)) *FacadeMock {
	if mmAcceptReturn.defaultExpectation != nil {
		mmAcceptReturn.mock.t.Fatalf("Default expectation is already set for the Facade.AcceptReturn method")
	}

	if len(mmAcceptReturn.expectations) > 0 {
		mmAcceptReturn.mock.t.Fatalf("Some expectations are already set for the Facade.AcceptReturn method")
	}

	mmAcceptReturn.mock.funcAcceptReturn = f
	mmAcceptReturn.mock.funcAcceptReturnOrigin = minimock.CallerInfo(1)
	return mmAcceptReturn.mock
}

// When sets expectation for the Facade.AcceptReturn which will trigger the result defined by the following
// Then helper
func (mmAcceptReturn *mFacadeMockAcceptReturn) When(ctx context.Context, clientID int64, orderID int64) *FacadeMockAcceptReturnExpectation {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("FacadeMock.AcceptReturn mock is already set by Set")
	}

	expectation := &FacadeMockAcceptReturnExpectation{
		mock:               mmAcceptReturn.mock,
		params:             &FacadeMockAcceptReturnParams{ctx, clientID, orderID},
		expectationOrigins: FacadeMockAcceptReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptReturn.expectations = append(mmAcceptReturn.expectations, expectation)
	return expectation
}

// Then sets up Facade.AcceptReturn return parameters for the expectation previously defined by the When method
func (e *FacadeMockAcceptReturnExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockAcceptReturnResults{err}
	return e.mock
}

// Times sets number of times Facade.AcceptReturn should be invoked
func (mmAcceptReturn *mFacadeMockAcceptReturn) Times(n uint64) *mFacadeMockAcceptReturn {
	if n == 0 {
		mmAcceptReturn.mock.t.Fatalf("Times of FacadeMock.AcceptReturn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptReturn.expectedInvocations, n)
	mmAcceptReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptReturn
}

func (mmAcceptReturn *mFacadeMockAcceptReturn) invocationsDone() bool {
	if len(mmAcceptReturn.expectations) == 0 && mmAcceptReturn.defaultExpectation == nil && mmAcceptReturn.mock.funcAcceptReturn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptReturn.mock.afterAcceptReturnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptReturn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptReturn implements mm_app.Facade
func (mmAcceptReturn *FacadeMock) AcceptReturn(ctx context.Context, clientID int64, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmAcceptReturn.beforeAcceptReturnCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptReturn.afterAcceptReturnCounter, 1)

	mmAcceptReturn.t.Helper()

	if mmAcceptReturn.inspectFuncAcceptReturn != nil {
		mmAcceptReturn.inspectFuncAcceptReturn(ctx, clientID, orderID)
	}

	mm_params := FacadeMockAcceptReturnParams{ctx, clientID, orderID}

	// Record call args
	mmAcceptReturn.AcceptReturnMock.mutex.Lock()
	mmAcceptReturn.AcceptReturnMock.callArgs = append(mmAcceptReturn.AcceptReturnMock.callArgs, &mm_params)
	mmAcceptReturn.AcceptReturnMock.mutex.Unlock()

	for _, e := range mmAcceptReturn.AcceptReturnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAcceptReturn.AcceptReturnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptReturn.AcceptReturnMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptReturn.AcceptReturnMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptReturn.AcceptReturnMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockAcceptReturnParams{ctx, clientID, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptReturn.t.Errorf("FacadeMock.AcceptReturn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmAcceptReturn.t.Errorf("FacadeMock.AcceptReturn got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmAcceptReturn.t.Errorf("FacadeMock.AcceptReturn got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptReturn.t.Errorf("FacadeMock.AcceptReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptReturn.AcceptReturnMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptReturn.t.Fatal("No results are set for the FacadeMock.AcceptReturn")
		}
		return (*mm_results).err
	}
	if mmAcceptReturn.funcAcceptReturn != nil {
		return mmAcceptReturn.funcAcceptReturn(ctx, clientID, orderID)
	}
	mmAcceptReturn.t.Fatalf("Unexpected call to FacadeMock.AcceptReturn. %v %v %v", ctx, clientID, orderID)
	return
}

// AcceptReturnAfterCounter returns a count of finished FacadeMock.AcceptReturn invocations
func (mmAcceptReturn *FacadeMock) AcceptReturnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptReturn.afterAcceptReturnCounter)
}

// AcceptReturnBeforeCounter returns a count of FacadeMock.AcceptReturn invocations
func (mmAcceptReturn *FacadeMock) AcceptReturnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptReturn.beforeAcceptReturnCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.AcceptReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptReturn *mFacadeMockAcceptReturn) Calls() []*FacadeMockAcceptReturnParams {
	mmAcceptReturn.mutex.RLock()

	argCopy := make([]*FacadeMockAcceptReturnParams, len(mmAcceptReturn.callArgs))
	copy(argCopy, mmAcceptReturn.callArgs)

	mmAcceptReturn.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptReturnDone returns true if the count of the AcceptReturn invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockAcceptReturnDone() bool {
	if m.AcceptReturnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptReturnMock.invocationsDone()
}

// MinimockAcceptReturnInspect logs each unmet expectation
func (m *FacadeMock) MinimockAcceptReturnInspect() {
	for _, e := range m.AcceptReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.AcceptReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptReturnCounter := mm_atomic.LoadUint64(&m.afterAcceptReturnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptReturnMock.defaultExpectation != nil && afterAcceptReturnCounter < 1 {
		if m.AcceptReturnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.AcceptReturn at\n%s", m.AcceptReturnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.AcceptReturn at\n%s with params: %#v", m.AcceptReturnMock.defaultExpectation.expectationOrigins.origin, *m.AcceptReturnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptReturn != nil && afterAcceptReturnCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.AcceptReturn at\n%s", m.funcAcceptReturnOrigin)
	}

	if !m.AcceptReturnMock.invocationsDone() && afterAcceptReturnCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.AcceptReturn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptReturnMock.expectedInvocations), m.AcceptReturnMock.expectedInvocationsOrigin, afterAcceptReturnCounter)
	}
}

type mFacadeMockAddOrder struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockAddOrderExpectation
	expectations       []*FacadeMockAddOrderExpectation

	callArgs []*FacadeMockAddOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockAddOrderExpectation specifies expectation struct of the Facade.AddOrder
type FacadeMockAddOrderExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockAddOrderParams
	paramPtrs          *FacadeMockAddOrderParamPtrs
	expectationOrigins FacadeMockAddOrderExpectationOrigins
	results            *FacadeMockAddOrderResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockAddOrderParams contains parameters of the Facade.AddOrder
type FacadeMockAddOrderParams struct {
	ctx             context.Context
	orderID         int64
	clientID        int64
	createdAt       time.Time
	expiredAt       time.Time
	weight          float64
	price           int64
	packaging       string
	additional_film string
}

// FacadeMockAddOrderParamPtrs contains pointers to parameters of the Facade.AddOrder
type FacadeMockAddOrderParamPtrs struct {
	ctx             *context.Context
	orderID         *int64
	clientID        *int64
	createdAt       *time.Time
	expiredAt       *time.Time
	weight          *float64
	price           *int64
	packaging       *string
	additional_film *string
}

// FacadeMockAddOrderResults contains results of the Facade.AddOrder
type FacadeMockAddOrderResults struct {
	err error
}

// FacadeMockAddOrderOrigins contains origins of expectations of the Facade.AddOrder
type FacadeMockAddOrderExpectationOrigins struct {
	origin                string
	originCtx             string
	originOrderID         string
	originClientID        string
	originCreatedAt       string
	originExpiredAt       string
	originWeight          string
	originPrice           string
	originPackaging       string
	originAdditional_film string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrder *mFacadeMockAddOrder) Optional() *mFacadeMockAddOrder {
	mmAddOrder.optional = true
	return mmAddOrder
}

// Expect sets up expected params for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) Expect(ctx context.Context, orderID int64, clientID int64, createdAt time.Time, expiredAt time.Time, weight float64, price int64, packaging string, additional_film string) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.paramPtrs != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by ExpectParams functions")
	}

	mmAddOrder.defaultExpectation.params = &FacadeMockAddOrderParams{ctx, orderID, clientID, createdAt, expiredAt, weight, price, packaging, additional_film}
	mmAddOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrder.expectations {
		if minimock.Equal(e.params, mmAddOrder.defaultExpectation.params) {
			mmAddOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrder.defaultExpectation.params)
		}
	}

	return mmAddOrder
}

// ExpectCtxParam1 sets up expected param ctx for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectCtxParam1(ctx context.Context) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectOrderIDParam2(orderID int64) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmAddOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectClientIDParam3 sets up expected param clientID for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectClientIDParam3(clientID int64) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.clientID = &clientID
	mmAddOrder.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectCreatedAtParam4 sets up expected param createdAt for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectCreatedAtParam4(createdAt time.Time) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.createdAt = &createdAt
	mmAddOrder.defaultExpectation.expectationOrigins.originCreatedAt = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectExpiredAtParam5 sets up expected param expiredAt for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectExpiredAtParam5(expiredAt time.Time) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.expiredAt = &expiredAt
	mmAddOrder.defaultExpectation.expectationOrigins.originExpiredAt = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectWeightParam6 sets up expected param weight for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectWeightParam6(weight float64) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.weight = &weight
	mmAddOrder.defaultExpectation.expectationOrigins.originWeight = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectPriceParam7 sets up expected param price for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectPriceParam7(price int64) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.price = &price
	mmAddOrder.defaultExpectation.expectationOrigins.originPrice = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectPackagingParam8 sets up expected param packaging for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectPackagingParam8(packaging string) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.packaging = &packaging
	mmAddOrder.defaultExpectation.expectationOrigins.originPackaging = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectAdditional_filmParam9 sets up expected param additional_film for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectAdditional_filmParam9(additional_film string) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.additional_film = &additional_film
	mmAddOrder.defaultExpectation.expectationOrigins.originAdditional_film = minimock.CallerInfo(1)

	return mmAddOrder
}

// Inspect accepts an inspector function that has same arguments as the Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) Inspect(f func(ctx context.Context, orderID int64, clientID int64, createdAt time.Time, expiredAt time.Time, weight float64, price int64, packaging string, additional_film string)) *mFacadeMockAddOrder {
	if mmAddOrder.mock.inspectFuncAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("Inspect function is already set for FacadeMock.AddOrder")
	}

	mmAddOrder.mock.inspectFuncAddOrder = f

	return mmAddOrder
}

// Return sets up results that will be returned by Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) Return(err error) *FacadeMock {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{mock: mmAddOrder.mock}
	}
	mmAddOrder.defaultExpectation.results = &FacadeMockAddOrderResults{err}
	mmAddOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// Set uses given function f to mock the Facade.AddOrder method
func (mmAddOrder *mFacadeMockAddOrder) Set(f func(ctx context.Context, orderID int64, clientID int64, createdAt time.Time, expiredAt time.Time, weight float64, price int64, packaging string, additional_film string) (err error)) *FacadeMock {
	if mmAddOrder.defaultExpectation != nil {
		mmAddOrder.mock.t.Fatalf("Default expectation is already set for the Facade.AddOrder method")
	}

	if len(mmAddOrder.expectations) > 0 {
		mmAddOrder.mock.t.Fatalf("Some expectations are already set for the Facade.AddOrder method")
	}

	mmAddOrder.mock.funcAddOrder = f
	mmAddOrder.mock.funcAddOrderOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// When sets expectation for the Facade.AddOrder which will trigger the result defined by the following
// Then helper
func (mmAddOrder *mFacadeMockAddOrder) When(ctx context.Context, orderID int64, clientID int64, createdAt time.Time, expiredAt time.Time, weight float64, price int64, packaging string, additional_film string) *FacadeMockAddOrderExpectation {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	expectation := &FacadeMockAddOrderExpectation{
		mock:               mmAddOrder.mock,
		params:             &FacadeMockAddOrderParams{ctx, orderID, clientID, createdAt, expiredAt, weight, price, packaging, additional_film},
		expectationOrigins: FacadeMockAddOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrder.expectations = append(mmAddOrder.expectations, expectation)
	return expectation
}

// Then sets up Facade.AddOrder return parameters for the expectation previously defined by the When method
func (e *FacadeMockAddOrderExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockAddOrderResults{err}
	return e.mock
}

// Times sets number of times Facade.AddOrder should be invoked
func (mmAddOrder *mFacadeMockAddOrder) Times(n uint64) *mFacadeMockAddOrder {
	if n == 0 {
		mmAddOrder.mock.t.Fatalf("Times of FacadeMock.AddOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrder.expectedInvocations, n)
	mmAddOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrder
}

func (mmAddOrder *mFacadeMockAddOrder) invocationsDone() bool {
	if len(mmAddOrder.expectations) == 0 && mmAddOrder.defaultExpectation == nil && mmAddOrder.mock.funcAddOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrder.mock.afterAddOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrder implements mm_app.Facade
func (mmAddOrder *FacadeMock) AddOrder(ctx context.Context, orderID int64, clientID int64, createdAt time.Time, expiredAt time.Time, weight float64, price int64, packaging string, additional_film string) (err error) {
	mm_atomic.AddUint64(&mmAddOrder.beforeAddOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrder.afterAddOrderCounter, 1)

	mmAddOrder.t.Helper()

	if mmAddOrder.inspectFuncAddOrder != nil {
		mmAddOrder.inspectFuncAddOrder(ctx, orderID, clientID, createdAt, expiredAt, weight, price, packaging, additional_film)
	}

	mm_params := FacadeMockAddOrderParams{ctx, orderID, clientID, createdAt, expiredAt, weight, price, packaging, additional_film}

	// Record call args
	mmAddOrder.AddOrderMock.mutex.Lock()
	mmAddOrder.AddOrderMock.callArgs = append(mmAddOrder.AddOrderMock.callArgs, &mm_params)
	mmAddOrder.AddOrderMock.mutex.Unlock()

	for _, e := range mmAddOrder.AddOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOrder.AddOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrder.AddOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrder.AddOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrder.AddOrderMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockAddOrderParams{ctx, orderID, clientID, createdAt, expiredAt, weight, price, packaging, additional_film}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

			if mm_want_ptrs.createdAt != nil && !minimock.Equal(*mm_want_ptrs.createdAt, mm_got.createdAt) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter createdAt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originCreatedAt, *mm_want_ptrs.createdAt, mm_got.createdAt, minimock.Diff(*mm_want_ptrs.createdAt, mm_got.createdAt))
			}

			if mm_want_ptrs.expiredAt != nil && !minimock.Equal(*mm_want_ptrs.expiredAt, mm_got.expiredAt) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter expiredAt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originExpiredAt, *mm_want_ptrs.expiredAt, mm_got.expiredAt, minimock.Diff(*mm_want_ptrs.expiredAt, mm_got.expiredAt))
			}

			if mm_want_ptrs.weight != nil && !minimock.Equal(*mm_want_ptrs.weight, mm_got.weight) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter weight, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originWeight, *mm_want_ptrs.weight, mm_got.weight, minimock.Diff(*mm_want_ptrs.weight, mm_got.weight))
			}

			if mm_want_ptrs.price != nil && !minimock.Equal(*mm_want_ptrs.price, mm_got.price) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter price, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originPrice, *mm_want_ptrs.price, mm_got.price, minimock.Diff(*mm_want_ptrs.price, mm_got.price))
			}

			if mm_want_ptrs.packaging != nil && !minimock.Equal(*mm_want_ptrs.packaging, mm_got.packaging) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter packaging, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originPackaging, *mm_want_ptrs.packaging, mm_got.packaging, minimock.Diff(*mm_want_ptrs.packaging, mm_got.packaging))
			}

			if mm_want_ptrs.additional_film != nil && !minimock.Equal(*mm_want_ptrs.additional_film, mm_got.additional_film) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter additional_film, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originAdditional_film, *mm_want_ptrs.additional_film, mm_got.additional_film, minimock.Diff(*mm_want_ptrs.additional_film, mm_got.additional_film))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrder.AddOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrder.t.Fatal("No results are set for the FacadeMock.AddOrder")
		}
		return (*mm_results).err
	}
	if mmAddOrder.funcAddOrder != nil {
		return mmAddOrder.funcAddOrder(ctx, orderID, clientID, createdAt, expiredAt, weight, price, packaging, additional_film)
	}
	mmAddOrder.t.Fatalf("Unexpected call to FacadeMock.AddOrder. %v %v %v %v %v %v %v %v %v", ctx, orderID, clientID, createdAt, expiredAt, weight, price, packaging, additional_film)
	return
}

// AddOrderAfterCounter returns a count of finished FacadeMock.AddOrder invocations
func (mmAddOrder *FacadeMock) AddOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.afterAddOrderCounter)
}

// AddOrderBeforeCounter returns a count of FacadeMock.AddOrder invocations
func (mmAddOrder *FacadeMock) AddOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.beforeAddOrderCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.AddOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrder *mFacadeMockAddOrder) Calls() []*FacadeMockAddOrderParams {
	mmAddOrder.mutex.RLock()

	argCopy := make([]*FacadeMockAddOrderParams, len(mmAddOrder.callArgs))
	copy(argCopy, mmAddOrder.callArgs)

	mmAddOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderDone returns true if the count of the AddOrder invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockAddOrderDone() bool {
	if m.AddOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderMock.invocationsDone()
}

// MinimockAddOrderInspect logs each unmet expectation
func (m *FacadeMock) MinimockAddOrderInspect() {
	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.AddOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderCounter := mm_atomic.LoadUint64(&m.afterAddOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderMock.defaultExpectation != nil && afterAddOrderCounter < 1 {
		if m.AddOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.AddOrder at\n%s", m.AddOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.AddOrder at\n%s with params: %#v", m.AddOrderMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrder != nil && afterAddOrderCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.AddOrder at\n%s", m.funcAddOrderOrigin)
	}

	if !m.AddOrderMock.invocationsDone() && afterAddOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.AddOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderMock.expectedInvocations), m.AddOrderMock.expectedInvocationsOrigin, afterAddOrderCounter)
	}
}

type mFacadeMockCheckOrderStatus struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockCheckOrderStatusExpectation
	expectations       []*FacadeMockCheckOrderStatusExpectation

	callArgs []*FacadeMockCheckOrderStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockCheckOrderStatusExpectation specifies expectation struct of the Facade.CheckOrderStatus
type FacadeMockCheckOrderStatusExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockCheckOrderStatusParams
	paramPtrs          *FacadeMockCheckOrderStatusParamPtrs
	expectationOrigins FacadeMockCheckOrderStatusExpectationOrigins
	results            *FacadeMockCheckOrderStatusResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockCheckOrderStatusParams contains parameters of the Facade.CheckOrderStatus
type FacadeMockCheckOrderStatusParams struct {
	ctx     context.Context
	orderID int64
}

// FacadeMockCheckOrderStatusParamPtrs contains pointers to parameters of the Facade.CheckOrderStatus
type FacadeMockCheckOrderStatusParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// FacadeMockCheckOrderStatusResults contains results of the Facade.CheckOrderStatus
type FacadeMockCheckOrderStatusResults struct {
	b1  bool
	b2  bool
	err error
}

// FacadeMockCheckOrderStatusOrigins contains origins of expectations of the Facade.CheckOrderStatus
type FacadeMockCheckOrderStatusExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) Optional() *mFacadeMockCheckOrderStatus {
	mmCheckOrderStatus.optional = true
	return mmCheckOrderStatus
}

// Expect sets up expected params for Facade.CheckOrderStatus
func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) Expect(ctx context.Context, orderID int64) *mFacadeMockCheckOrderStatus {
	if mmCheckOrderStatus.mock.funcCheckOrderStatus != nil {
		mmCheckOrderStatus.mock.t.Fatalf("FacadeMock.CheckOrderStatus mock is already set by Set")
	}

	if mmCheckOrderStatus.defaultExpectation == nil {
		mmCheckOrderStatus.defaultExpectation = &FacadeMockCheckOrderStatusExpectation{}
	}

	if mmCheckOrderStatus.defaultExpectation.paramPtrs != nil {
		mmCheckOrderStatus.mock.t.Fatalf("FacadeMock.CheckOrderStatus mock is already set by ExpectParams functions")
	}

	mmCheckOrderStatus.defaultExpectation.params = &FacadeMockCheckOrderStatusParams{ctx, orderID}
	mmCheckOrderStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckOrderStatus.expectations {
		if minimock.Equal(e.params, mmCheckOrderStatus.defaultExpectation.params) {
			mmCheckOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckOrderStatus.defaultExpectation.params)
		}
	}

	return mmCheckOrderStatus
}

// ExpectCtxParam1 sets up expected param ctx for Facade.CheckOrderStatus
func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) ExpectCtxParam1(ctx context.Context) *mFacadeMockCheckOrderStatus {
	if mmCheckOrderStatus.mock.funcCheckOrderStatus != nil {
		mmCheckOrderStatus.mock.t.Fatalf("FacadeMock.CheckOrderStatus mock is already set by Set")
	}

	if mmCheckOrderStatus.defaultExpectation == nil {
		mmCheckOrderStatus.defaultExpectation = &FacadeMockCheckOrderStatusExpectation{}
	}

	if mmCheckOrderStatus.defaultExpectation.params != nil {
		mmCheckOrderStatus.mock.t.Fatalf("FacadeMock.CheckOrderStatus mock is already set by Expect")
	}

	if mmCheckOrderStatus.defaultExpectation.paramPtrs == nil {
		mmCheckOrderStatus.defaultExpectation.paramPtrs = &FacadeMockCheckOrderStatusParamPtrs{}
	}
	mmCheckOrderStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckOrderStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckOrderStatus
}

// ExpectOrderIDParam2 sets up expected param orderID for Facade.CheckOrderStatus
func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) ExpectOrderIDParam2(orderID int64) *mFacadeMockCheckOrderStatus {
	if mmCheckOrderStatus.mock.funcCheckOrderStatus != nil {
		mmCheckOrderStatus.mock.t.Fatalf("FacadeMock.CheckOrderStatus mock is already set by Set")
	}

	if mmCheckOrderStatus.defaultExpectation == nil {
		mmCheckOrderStatus.defaultExpectation = &FacadeMockCheckOrderStatusExpectation{}
	}

	if mmCheckOrderStatus.defaultExpectation.params != nil {
		mmCheckOrderStatus.mock.t.Fatalf("FacadeMock.CheckOrderStatus mock is already set by Expect")
	}

	if mmCheckOrderStatus.defaultExpectation.paramPtrs == nil {
		mmCheckOrderStatus.defaultExpectation.paramPtrs = &FacadeMockCheckOrderStatusParamPtrs{}
	}
	mmCheckOrderStatus.defaultExpectation.paramPtrs.orderID = &orderID
	mmCheckOrderStatus.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmCheckOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the Facade.CheckOrderStatus
func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) Inspect(f func(ctx context.Context, orderID int64)) *mFacadeMockCheckOrderStatus {
	if mmCheckOrderStatus.mock.inspectFuncCheckOrderStatus != nil {
		mmCheckOrderStatus.mock.t.Fatalf("Inspect function is already set for FacadeMock.CheckOrderStatus")
	}

	mmCheckOrderStatus.mock.inspectFuncCheckOrderStatus = f

	return mmCheckOrderStatus
}

// Return sets up results that will be returned by Facade.CheckOrderStatus
func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) Return(b1 bool, b2 bool, err error) *FacadeMock {
	if mmCheckOrderStatus.mock.funcCheckOrderStatus != nil {
		mmCheckOrderStatus.mock.t.Fatalf("FacadeMock.CheckOrderStatus mock is already set by Set")
	}

	if mmCheckOrderStatus.defaultExpectation == nil {
		mmCheckOrderStatus.defaultExpectation = &FacadeMockCheckOrderStatusExpectation{mock: mmCheckOrderStatus.mock}
	}
	mmCheckOrderStatus.defaultExpectation.results = &FacadeMockCheckOrderStatusResults{b1, b2, err}
	mmCheckOrderStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckOrderStatus.mock
}

// Set uses given function f to mock the Facade.CheckOrderStatus method
func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) Set(f func(ctx context.Context, orderID int64) (b1 bool, b2 bool, err error)) *FacadeMock {
	if mmCheckOrderStatus.defaultExpectation != nil {
		mmCheckOrderStatus.mock.t.Fatalf("Default expectation is already set for the Facade.CheckOrderStatus method")
	}

	if len(mmCheckOrderStatus.expectations) > 0 {
		mmCheckOrderStatus.mock.t.Fatalf("Some expectations are already set for the Facade.CheckOrderStatus method")
	}

	mmCheckOrderStatus.mock.funcCheckOrderStatus = f
	mmCheckOrderStatus.mock.funcCheckOrderStatusOrigin = minimock.CallerInfo(1)
	return mmCheckOrderStatus.mock
}

// When sets expectation for the Facade.CheckOrderStatus which will trigger the result defined by the following
// Then helper
func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) When(ctx context.Context, orderID int64) *FacadeMockCheckOrderStatusExpectation {
	if mmCheckOrderStatus.mock.funcCheckOrderStatus != nil {
		mmCheckOrderStatus.mock.t.Fatalf("FacadeMock.CheckOrderStatus mock is already set by Set")
	}

	expectation := &FacadeMockCheckOrderStatusExpectation{
		mock:               mmCheckOrderStatus.mock,
		params:             &FacadeMockCheckOrderStatusParams{ctx, orderID},
		expectationOrigins: FacadeMockCheckOrderStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckOrderStatus.expectations = append(mmCheckOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up Facade.CheckOrderStatus return parameters for the expectation previously defined by the When method
func (e *FacadeMockCheckOrderStatusExpectation) Then(b1 bool, b2 bool, err error) *FacadeMock {
	e.results = &FacadeMockCheckOrderStatusResults{b1, b2, err}
	return e.mock
}

// Times sets number of times Facade.CheckOrderStatus should be invoked
func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) Times(n uint64) *mFacadeMockCheckOrderStatus {
	if n == 0 {
		mmCheckOrderStatus.mock.t.Fatalf("Times of FacadeMock.CheckOrderStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckOrderStatus.expectedInvocations, n)
	mmCheckOrderStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckOrderStatus
}

func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) invocationsDone() bool {
	if len(mmCheckOrderStatus.expectations) == 0 && mmCheckOrderStatus.defaultExpectation == nil && mmCheckOrderStatus.mock.funcCheckOrderStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckOrderStatus.mock.afterCheckOrderStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckOrderStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckOrderStatus implements mm_app.Facade
func (mmCheckOrderStatus *FacadeMock) CheckOrderStatus(ctx context.Context, orderID int64) (b1 bool, b2 bool, err error) {
	mm_atomic.AddUint64(&mmCheckOrderStatus.beforeCheckOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckOrderStatus.afterCheckOrderStatusCounter, 1)

	mmCheckOrderStatus.t.Helper()

	if mmCheckOrderStatus.inspectFuncCheckOrderStatus != nil {
		mmCheckOrderStatus.inspectFuncCheckOrderStatus(ctx, orderID)
	}

	mm_params := FacadeMockCheckOrderStatusParams{ctx, orderID}

	// Record call args
	mmCheckOrderStatus.CheckOrderStatusMock.mutex.Lock()
	mmCheckOrderStatus.CheckOrderStatusMock.callArgs = append(mmCheckOrderStatus.CheckOrderStatusMock.callArgs, &mm_params)
	mmCheckOrderStatus.CheckOrderStatusMock.mutex.Unlock()

	for _, e := range mmCheckOrderStatus.CheckOrderStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.b2, e.results.err
		}
	}

	if mmCheckOrderStatus.CheckOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckOrderStatus.CheckOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckOrderStatus.CheckOrderStatusMock.defaultExpectation.params
		mm_want_ptrs := mmCheckOrderStatus.CheckOrderStatusMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockCheckOrderStatusParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckOrderStatus.t.Errorf("FacadeMock.CheckOrderStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckOrderStatus.CheckOrderStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmCheckOrderStatus.t.Errorf("FacadeMock.CheckOrderStatus got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckOrderStatus.CheckOrderStatusMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckOrderStatus.t.Errorf("FacadeMock.CheckOrderStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckOrderStatus.CheckOrderStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckOrderStatus.CheckOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckOrderStatus.t.Fatal("No results are set for the FacadeMock.CheckOrderStatus")
		}
		return (*mm_results).b1, (*mm_results).b2, (*mm_results).err
	}
	if mmCheckOrderStatus.funcCheckOrderStatus != nil {
		return mmCheckOrderStatus.funcCheckOrderStatus(ctx, orderID)
	}
	mmCheckOrderStatus.t.Fatalf("Unexpected call to FacadeMock.CheckOrderStatus. %v %v", ctx, orderID)
	return
}

// CheckOrderStatusAfterCounter returns a count of finished FacadeMock.CheckOrderStatus invocations
func (mmCheckOrderStatus *FacadeMock) CheckOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckOrderStatus.afterCheckOrderStatusCounter)
}

// CheckOrderStatusBeforeCounter returns a count of FacadeMock.CheckOrderStatus invocations
func (mmCheckOrderStatus *FacadeMock) CheckOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckOrderStatus.beforeCheckOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.CheckOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckOrderStatus *mFacadeMockCheckOrderStatus) Calls() []*FacadeMockCheckOrderStatusParams {
	mmCheckOrderStatus.mutex.RLock()

	argCopy := make([]*FacadeMockCheckOrderStatusParams, len(mmCheckOrderStatus.callArgs))
	copy(argCopy, mmCheckOrderStatus.callArgs)

	mmCheckOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockCheckOrderStatusDone returns true if the count of the CheckOrderStatus invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockCheckOrderStatusDone() bool {
	if m.CheckOrderStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckOrderStatusMock.invocationsDone()
}

// MinimockCheckOrderStatusInspect logs each unmet expectation
func (m *FacadeMock) MinimockCheckOrderStatusInspect() {
	for _, e := range m.CheckOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.CheckOrderStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckOrderStatusCounter := mm_atomic.LoadUint64(&m.afterCheckOrderStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckOrderStatusMock.defaultExpectation != nil && afterCheckOrderStatusCounter < 1 {
		if m.CheckOrderStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.CheckOrderStatus at\n%s", m.CheckOrderStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.CheckOrderStatus at\n%s with params: %#v", m.CheckOrderStatusMock.defaultExpectation.expectationOrigins.origin, *m.CheckOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckOrderStatus != nil && afterCheckOrderStatusCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.CheckOrderStatus at\n%s", m.funcCheckOrderStatusOrigin)
	}

	if !m.CheckOrderStatusMock.invocationsDone() && afterCheckOrderStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.CheckOrderStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckOrderStatusMock.expectedInvocations), m.CheckOrderStatusMock.expectedInvocationsOrigin, afterCheckOrderStatusCounter)
	}
}

type mFacadeMockDeleteOrder struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockDeleteOrderExpectation
	expectations       []*FacadeMockDeleteOrderExpectation

	callArgs []*FacadeMockDeleteOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockDeleteOrderExpectation specifies expectation struct of the Facade.DeleteOrder
type FacadeMockDeleteOrderExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockDeleteOrderParams
	paramPtrs          *FacadeMockDeleteOrderParamPtrs
	expectationOrigins FacadeMockDeleteOrderExpectationOrigins
	results            *FacadeMockDeleteOrderResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockDeleteOrderParams contains parameters of the Facade.DeleteOrder
type FacadeMockDeleteOrderParams struct {
	ctx     context.Context
	orderID int64
}

// FacadeMockDeleteOrderParamPtrs contains pointers to parameters of the Facade.DeleteOrder
type FacadeMockDeleteOrderParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// FacadeMockDeleteOrderResults contains results of the Facade.DeleteOrder
type FacadeMockDeleteOrderResults struct {
	err error
}

// FacadeMockDeleteOrderOrigins contains origins of expectations of the Facade.DeleteOrder
type FacadeMockDeleteOrderExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrder *mFacadeMockDeleteOrder) Optional() *mFacadeMockDeleteOrder {
	mmDeleteOrder.optional = true
	return mmDeleteOrder
}

// Expect sets up expected params for Facade.DeleteOrder
func (mmDeleteOrder *mFacadeMockDeleteOrder) Expect(ctx context.Context, orderID int64) *mFacadeMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("FacadeMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &FacadeMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs != nil {
		mmDeleteOrder.mock.t.Fatalf("FacadeMock.DeleteOrder mock is already set by ExpectParams functions")
	}

	mmDeleteOrder.defaultExpectation.params = &FacadeMockDeleteOrderParams{ctx, orderID}
	mmDeleteOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteOrder.expectations {
		if minimock.Equal(e.params, mmDeleteOrder.defaultExpectation.params) {
			mmDeleteOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrder.defaultExpectation.params)
		}
	}

	return mmDeleteOrder
}

// ExpectCtxParam1 sets up expected param ctx for Facade.DeleteOrder
func (mmDeleteOrder *mFacadeMockDeleteOrder) ExpectCtxParam1(ctx context.Context) *mFacadeMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("FacadeMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &FacadeMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("FacadeMock.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &FacadeMockDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for Facade.DeleteOrder
func (mmDeleteOrder *mFacadeMockDeleteOrder) ExpectOrderIDParam2(orderID int64) *mFacadeMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("FacadeMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &FacadeMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("FacadeMock.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &FacadeMockDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmDeleteOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmDeleteOrder
}

// Inspect accepts an inspector function that has same arguments as the Facade.DeleteOrder
func (mmDeleteOrder *mFacadeMockDeleteOrder) Inspect(f func(ctx context.Context, orderID int64)) *mFacadeMockDeleteOrder {
	if mmDeleteOrder.mock.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Inspect function is already set for FacadeMock.DeleteOrder")
	}

	mmDeleteOrder.mock.inspectFuncDeleteOrder = f

	return mmDeleteOrder
}

// Return sets up results that will be returned by Facade.DeleteOrder
func (mmDeleteOrder *mFacadeMockDeleteOrder) Return(err error) *FacadeMock {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("FacadeMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &FacadeMockDeleteOrderExpectation{mock: mmDeleteOrder.mock}
	}
	mmDeleteOrder.defaultExpectation.results = &FacadeMockDeleteOrderResults{err}
	mmDeleteOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder.mock
}

// Set uses given function f to mock the Facade.DeleteOrder method
func (mmDeleteOrder *mFacadeMockDeleteOrder) Set(f func(ctx context.Context, orderID int64) (err error)) *FacadeMock {
	if mmDeleteOrder.defaultExpectation != nil {
		mmDeleteOrder.mock.t.Fatalf("Default expectation is already set for the Facade.DeleteOrder method")
	}

	if len(mmDeleteOrder.expectations) > 0 {
		mmDeleteOrder.mock.t.Fatalf("Some expectations are already set for the Facade.DeleteOrder method")
	}

	mmDeleteOrder.mock.funcDeleteOrder = f
	mmDeleteOrder.mock.funcDeleteOrderOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder.mock
}

// When sets expectation for the Facade.DeleteOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteOrder *mFacadeMockDeleteOrder) When(ctx context.Context, orderID int64) *FacadeMockDeleteOrderExpectation {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("FacadeMock.DeleteOrder mock is already set by Set")
	}

	expectation := &FacadeMockDeleteOrderExpectation{
		mock:               mmDeleteOrder.mock,
		params:             &FacadeMockDeleteOrderParams{ctx, orderID},
		expectationOrigins: FacadeMockDeleteOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteOrder.expectations = append(mmDeleteOrder.expectations, expectation)
	return expectation
}

// Then sets up Facade.DeleteOrder return parameters for the expectation previously defined by the When method
func (e *FacadeMockDeleteOrderExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockDeleteOrderResults{err}
	return e.mock
}

// Times sets number of times Facade.DeleteOrder should be invoked
func (mmDeleteOrder *mFacadeMockDeleteOrder) Times(n uint64) *mFacadeMockDeleteOrder {
	if n == 0 {
		mmDeleteOrder.mock.t.Fatalf("Times of FacadeMock.DeleteOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOrder.expectedInvocations, n)
	mmDeleteOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder
}

func (mmDeleteOrder *mFacadeMockDeleteOrder) invocationsDone() bool {
	if len(mmDeleteOrder.expectations) == 0 && mmDeleteOrder.defaultExpectation == nil && mmDeleteOrder.mock.funcDeleteOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.mock.afterDeleteOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOrder implements mm_app.Facade
func (mmDeleteOrder *FacadeMock) DeleteOrder(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrder.beforeDeleteOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrder.afterDeleteOrderCounter, 1)

	mmDeleteOrder.t.Helper()

	if mmDeleteOrder.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.inspectFuncDeleteOrder(ctx, orderID)
	}

	mm_params := FacadeMockDeleteOrderParams{ctx, orderID}

	// Record call args
	mmDeleteOrder.DeleteOrderMock.mutex.Lock()
	mmDeleteOrder.DeleteOrderMock.callArgs = append(mmDeleteOrder.DeleteOrderMock.callArgs, &mm_params)
	mmDeleteOrder.DeleteOrderMock.mutex.Unlock()

	for _, e := range mmDeleteOrder.DeleteOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrder.DeleteOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrder.DeleteOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrder.DeleteOrderMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOrder.DeleteOrderMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockDeleteOrderParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteOrder.t.Errorf("FacadeMock.DeleteOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmDeleteOrder.t.Errorf("FacadeMock.DeleteOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrder.t.Errorf("FacadeMock.DeleteOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrder.DeleteOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrder.t.Fatal("No results are set for the FacadeMock.DeleteOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteOrder.funcDeleteOrder != nil {
		return mmDeleteOrder.funcDeleteOrder(ctx, orderID)
	}
	mmDeleteOrder.t.Fatalf("Unexpected call to FacadeMock.DeleteOrder. %v %v", ctx, orderID)
	return
}

// DeleteOrderAfterCounter returns a count of finished FacadeMock.DeleteOrder invocations
func (mmDeleteOrder *FacadeMock) DeleteOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.afterDeleteOrderCounter)
}

// DeleteOrderBeforeCounter returns a count of FacadeMock.DeleteOrder invocations
func (mmDeleteOrder *FacadeMock) DeleteOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.beforeDeleteOrderCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.DeleteOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrder *mFacadeMockDeleteOrder) Calls() []*FacadeMockDeleteOrderParams {
	mmDeleteOrder.mutex.RLock()

	argCopy := make([]*FacadeMockDeleteOrderParams, len(mmDeleteOrder.callArgs))
	copy(argCopy, mmDeleteOrder.callArgs)

	mmDeleteOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderDone returns true if the count of the DeleteOrder invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockDeleteOrderDone() bool {
	if m.DeleteOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOrderMock.invocationsDone()
}

// MinimockDeleteOrderInspect logs each unmet expectation
func (m *FacadeMock) MinimockDeleteOrderInspect() {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.DeleteOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteOrderCounter := mm_atomic.LoadUint64(&m.afterDeleteOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && afterDeleteOrderCounter < 1 {
		if m.DeleteOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.DeleteOrder at\n%s", m.DeleteOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.DeleteOrder at\n%s with params: %#v", m.DeleteOrderMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && afterDeleteOrderCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.DeleteOrder at\n%s", m.funcDeleteOrderOrigin)
	}

	if !m.DeleteOrderMock.invocationsDone() && afterDeleteOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.DeleteOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOrderMock.expectedInvocations), m.DeleteOrderMock.expectedInvocationsOrigin, afterDeleteOrderCounter)
	}
}

type mFacadeMockGetOrders struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGetOrdersExpectation
	expectations       []*FacadeMockGetOrdersExpectation

	callArgs []*FacadeMockGetOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGetOrdersExpectation specifies expectation struct of the Facade.GetOrders
type FacadeMockGetOrdersExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGetOrdersParams
	paramPtrs          *FacadeMockGetOrdersParamPtrs
	expectationOrigins FacadeMockGetOrdersExpectationOrigins
	results            *FacadeMockGetOrdersResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGetOrdersParams contains parameters of the Facade.GetOrders
type FacadeMockGetOrdersParams struct {
	ctx      context.Context
	clientID int64
}

// FacadeMockGetOrdersParamPtrs contains pointers to parameters of the Facade.GetOrders
type FacadeMockGetOrdersParamPtrs struct {
	ctx      *context.Context
	clientID *int64
}

// FacadeMockGetOrdersResults contains results of the Facade.GetOrders
type FacadeMockGetOrdersResults struct {
	opa1 []*postgres.Order
	err  error
}

// FacadeMockGetOrdersOrigins contains origins of expectations of the Facade.GetOrders
type FacadeMockGetOrdersExpectationOrigins struct {
	origin         string
	originCtx      string
	originClientID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrders *mFacadeMockGetOrders) Optional() *mFacadeMockGetOrders {
	mmGetOrders.optional = true
	return mmGetOrders
}

// Expect sets up expected params for Facade.GetOrders
func (mmGetOrders *mFacadeMockGetOrders) Expect(ctx context.Context, clientID int64) *mFacadeMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("FacadeMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &FacadeMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.paramPtrs != nil {
		mmGetOrders.mock.t.Fatalf("FacadeMock.GetOrders mock is already set by ExpectParams functions")
	}

	mmGetOrders.defaultExpectation.params = &FacadeMockGetOrdersParams{ctx, clientID}
	mmGetOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrders.expectations {
		if minimock.Equal(e.params, mmGetOrders.defaultExpectation.params) {
			mmGetOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrders.defaultExpectation.params)
		}
	}

	return mmGetOrders
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GetOrders
func (mmGetOrders *mFacadeMockGetOrders) ExpectCtxParam1(ctx context.Context) *mFacadeMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("FacadeMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &FacadeMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("FacadeMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &FacadeMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrders
}

// ExpectClientIDParam2 sets up expected param clientID for Facade.GetOrders
func (mmGetOrders *mFacadeMockGetOrders) ExpectClientIDParam2(clientID int64) *mFacadeMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("FacadeMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &FacadeMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("FacadeMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &FacadeMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.clientID = &clientID
	mmGetOrders.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmGetOrders
}

// Inspect accepts an inspector function that has same arguments as the Facade.GetOrders
func (mmGetOrders *mFacadeMockGetOrders) Inspect(f func(ctx context.Context, clientID int64)) *mFacadeMockGetOrders {
	if mmGetOrders.mock.inspectFuncGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("Inspect function is already set for FacadeMock.GetOrders")
	}

	mmGetOrders.mock.inspectFuncGetOrders = f

	return mmGetOrders
}

// Return sets up results that will be returned by Facade.GetOrders
func (mmGetOrders *mFacadeMockGetOrders) Return(opa1 []*postgres.Order, err error) *FacadeMock {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("FacadeMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &FacadeMockGetOrdersExpectation{mock: mmGetOrders.mock}
	}
	mmGetOrders.defaultExpectation.results = &FacadeMockGetOrdersResults{opa1, err}
	mmGetOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// Set uses given function f to mock the Facade.GetOrders method
func (mmGetOrders *mFacadeMockGetOrders) Set(f func(ctx context.Context, clientID int64) (opa1 []*postgres.Order, err error)) *FacadeMock {
	if mmGetOrders.defaultExpectation != nil {
		mmGetOrders.mock.t.Fatalf("Default expectation is already set for the Facade.GetOrders method")
	}

	if len(mmGetOrders.expectations) > 0 {
		mmGetOrders.mock.t.Fatalf("Some expectations are already set for the Facade.GetOrders method")
	}

	mmGetOrders.mock.funcGetOrders = f
	mmGetOrders.mock.funcGetOrdersOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// When sets expectation for the Facade.GetOrders which will trigger the result defined by the following
// Then helper
func (mmGetOrders *mFacadeMockGetOrders) When(ctx context.Context, clientID int64) *FacadeMockGetOrdersExpectation {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("FacadeMock.GetOrders mock is already set by Set")
	}

	expectation := &FacadeMockGetOrdersExpectation{
		mock:               mmGetOrders.mock,
		params:             &FacadeMockGetOrdersParams{ctx, clientID},
		expectationOrigins: FacadeMockGetOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrders.expectations = append(mmGetOrders.expectations, expectation)
	return expectation
}

// Then sets up Facade.GetOrders return parameters for the expectation previously defined by the When method
func (e *FacadeMockGetOrdersExpectation) Then(opa1 []*postgres.Order, err error) *FacadeMock {
	e.results = &FacadeMockGetOrdersResults{opa1, err}
	return e.mock
}

// Times sets number of times Facade.GetOrders should be invoked
func (mmGetOrders *mFacadeMockGetOrders) Times(n uint64) *mFacadeMockGetOrders {
	if n == 0 {
		mmGetOrders.mock.t.Fatalf("Times of FacadeMock.GetOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrders.expectedInvocations, n)
	mmGetOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrders
}

func (mmGetOrders *mFacadeMockGetOrders) invocationsDone() bool {
	if len(mmGetOrders.expectations) == 0 && mmGetOrders.defaultExpectation == nil && mmGetOrders.mock.funcGetOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrders.mock.afterGetOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrders implements mm_app.Facade
func (mmGetOrders *FacadeMock) GetOrders(ctx context.Context, clientID int64) (opa1 []*postgres.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrders.beforeGetOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrders.afterGetOrdersCounter, 1)

	mmGetOrders.t.Helper()

	if mmGetOrders.inspectFuncGetOrders != nil {
		mmGetOrders.inspectFuncGetOrders(ctx, clientID)
	}

	mm_params := FacadeMockGetOrdersParams{ctx, clientID}

	// Record call args
	mmGetOrders.GetOrdersMock.mutex.Lock()
	mmGetOrders.GetOrdersMock.callArgs = append(mmGetOrders.GetOrdersMock.callArgs, &mm_params)
	mmGetOrders.GetOrdersMock.mutex.Unlock()

	for _, e := range mmGetOrders.GetOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmGetOrders.GetOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrders.GetOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrders.GetOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrders.GetOrdersMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGetOrdersParams{ctx, clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrders.t.Errorf("FacadeMock.GetOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmGetOrders.t.Errorf("FacadeMock.GetOrders got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrders.t.Errorf("FacadeMock.GetOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrders.GetOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrders.t.Fatal("No results are set for the FacadeMock.GetOrders")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmGetOrders.funcGetOrders != nil {
		return mmGetOrders.funcGetOrders(ctx, clientID)
	}
	mmGetOrders.t.Fatalf("Unexpected call to FacadeMock.GetOrders. %v %v", ctx, clientID)
	return
}

// GetOrdersAfterCounter returns a count of finished FacadeMock.GetOrders invocations
func (mmGetOrders *FacadeMock) GetOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.afterGetOrdersCounter)
}

// GetOrdersBeforeCounter returns a count of FacadeMock.GetOrders invocations
func (mmGetOrders *FacadeMock) GetOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.beforeGetOrdersCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GetOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrders *mFacadeMockGetOrders) Calls() []*FacadeMockGetOrdersParams {
	mmGetOrders.mutex.RLock()

	argCopy := make([]*FacadeMockGetOrdersParams, len(mmGetOrders.callArgs))
	copy(argCopy, mmGetOrders.callArgs)

	mmGetOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersDone returns true if the count of the GetOrders invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGetOrdersDone() bool {
	if m.GetOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersMock.invocationsDone()
}

// MinimockGetOrdersInspect logs each unmet expectation
func (m *FacadeMock) MinimockGetOrdersInspect() {
	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GetOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersCounter := mm_atomic.LoadUint64(&m.afterGetOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersMock.defaultExpectation != nil && afterGetOrdersCounter < 1 {
		if m.GetOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GetOrders at\n%s", m.GetOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GetOrders at\n%s with params: %#v", m.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrders != nil && afterGetOrdersCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GetOrders at\n%s", m.funcGetOrdersOrigin)
	}

	if !m.GetOrdersMock.invocationsDone() && afterGetOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GetOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersMock.expectedInvocations), m.GetOrdersMock.expectedInvocationsOrigin, afterGetOrdersCounter)
	}
}

type mFacadeMockGetOrdersByIDs struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGetOrdersByIDsExpectation
	expectations       []*FacadeMockGetOrdersByIDsExpectation

	callArgs []*FacadeMockGetOrdersByIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGetOrdersByIDsExpectation specifies expectation struct of the Facade.GetOrdersByIDs
type FacadeMockGetOrdersByIDsExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGetOrdersByIDsParams
	paramPtrs          *FacadeMockGetOrdersByIDsParamPtrs
	expectationOrigins FacadeMockGetOrdersByIDsExpectationOrigins
	results            *FacadeMockGetOrdersByIDsResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGetOrdersByIDsParams contains parameters of the Facade.GetOrdersByIDs
type FacadeMockGetOrdersByIDsParams struct {
	ctx      context.Context
	orderIDs []int64
}

// FacadeMockGetOrdersByIDsParamPtrs contains pointers to parameters of the Facade.GetOrdersByIDs
type FacadeMockGetOrdersByIDsParamPtrs struct {
	ctx      *context.Context
	orderIDs *[]int64
}

// FacadeMockGetOrdersByIDsResults contains results of the Facade.GetOrdersByIDs
type FacadeMockGetOrdersByIDsResults struct {
	opa1 []*postgres.Order
	err  error
}

// FacadeMockGetOrdersByIDsOrigins contains origins of expectations of the Facade.GetOrdersByIDs
type FacadeMockGetOrdersByIDsExpectationOrigins struct {
	origin         string
	originCtx      string
	originOrderIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) Optional() *mFacadeMockGetOrdersByIDs {
	mmGetOrdersByIDs.optional = true
	return mmGetOrdersByIDs
}

// Expect sets up expected params for Facade.GetOrdersByIDs
func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) Expect(ctx context.Context, orderIDs []int64) *mFacadeMockGetOrdersByIDs {
	if mmGetOrdersByIDs.mock.funcGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("FacadeMock.GetOrdersByIDs mock is already set by Set")
	}

	if mmGetOrdersByIDs.defaultExpectation == nil {
		mmGetOrdersByIDs.defaultExpectation = &FacadeMockGetOrdersByIDsExpectation{}
	}

	if mmGetOrdersByIDs.defaultExpectation.paramPtrs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("FacadeMock.GetOrdersByIDs mock is already set by ExpectParams functions")
	}

	mmGetOrdersByIDs.defaultExpectation.params = &FacadeMockGetOrdersByIDsParams{ctx, orderIDs}
	mmGetOrdersByIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrdersByIDs.expectations {
		if minimock.Equal(e.params, mmGetOrdersByIDs.defaultExpectation.params) {
			mmGetOrdersByIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrdersByIDs.defaultExpectation.params)
		}
	}

	return mmGetOrdersByIDs
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GetOrdersByIDs
func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) ExpectCtxParam1(ctx context.Context) *mFacadeMockGetOrdersByIDs {
	if mmGetOrdersByIDs.mock.funcGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("FacadeMock.GetOrdersByIDs mock is already set by Set")
	}

	if mmGetOrdersByIDs.defaultExpectation == nil {
		mmGetOrdersByIDs.defaultExpectation = &FacadeMockGetOrdersByIDsExpectation{}
	}

	if mmGetOrdersByIDs.defaultExpectation.params != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("FacadeMock.GetOrdersByIDs mock is already set by Expect")
	}

	if mmGetOrdersByIDs.defaultExpectation.paramPtrs == nil {
		mmGetOrdersByIDs.defaultExpectation.paramPtrs = &FacadeMockGetOrdersByIDsParamPtrs{}
	}
	mmGetOrdersByIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrdersByIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrdersByIDs
}

// ExpectOrderIDsParam2 sets up expected param orderIDs for Facade.GetOrdersByIDs
func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) ExpectOrderIDsParam2(orderIDs []int64) *mFacadeMockGetOrdersByIDs {
	if mmGetOrdersByIDs.mock.funcGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("FacadeMock.GetOrdersByIDs mock is already set by Set")
	}

	if mmGetOrdersByIDs.defaultExpectation == nil {
		mmGetOrdersByIDs.defaultExpectation = &FacadeMockGetOrdersByIDsExpectation{}
	}

	if mmGetOrdersByIDs.defaultExpectation.params != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("FacadeMock.GetOrdersByIDs mock is already set by Expect")
	}

	if mmGetOrdersByIDs.defaultExpectation.paramPtrs == nil {
		mmGetOrdersByIDs.defaultExpectation.paramPtrs = &FacadeMockGetOrdersByIDsParamPtrs{}
	}
	mmGetOrdersByIDs.defaultExpectation.paramPtrs.orderIDs = &orderIDs
	mmGetOrdersByIDs.defaultExpectation.expectationOrigins.originOrderIDs = minimock.CallerInfo(1)

	return mmGetOrdersByIDs
}

// Inspect accepts an inspector function that has same arguments as the Facade.GetOrdersByIDs
func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) Inspect(f func(ctx context.Context, orderIDs []int64)) *mFacadeMockGetOrdersByIDs {
	if mmGetOrdersByIDs.mock.inspectFuncGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("Inspect function is already set for FacadeMock.GetOrdersByIDs")
	}

	mmGetOrdersByIDs.mock.inspectFuncGetOrdersByIDs = f

	return mmGetOrdersByIDs
}

// Return sets up results that will be returned by Facade.GetOrdersByIDs
func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) Return(opa1 []*postgres.Order, err error) *FacadeMock {
	if mmGetOrdersByIDs.mock.funcGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("FacadeMock.GetOrdersByIDs mock is already set by Set")
	}

	if mmGetOrdersByIDs.defaultExpectation == nil {
		mmGetOrdersByIDs.defaultExpectation = &FacadeMockGetOrdersByIDsExpectation{mock: mmGetOrdersByIDs.mock}
	}
	mmGetOrdersByIDs.defaultExpectation.results = &FacadeMockGetOrdersByIDsResults{opa1, err}
	mmGetOrdersByIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByIDs.mock
}

// Set uses given function f to mock the Facade.GetOrdersByIDs method
func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) Set(f func(ctx context.Context, orderIDs []int64) (opa1 []*postgres.Order, err error)) *FacadeMock {
	if mmGetOrdersByIDs.defaultExpectation != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("Default expectation is already set for the Facade.GetOrdersByIDs method")
	}

	if len(mmGetOrdersByIDs.expectations) > 0 {
		mmGetOrdersByIDs.mock.t.Fatalf("Some expectations are already set for the Facade.GetOrdersByIDs method")
	}

	mmGetOrdersByIDs.mock.funcGetOrdersByIDs = f
	mmGetOrdersByIDs.mock.funcGetOrdersByIDsOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByIDs.mock
}

// When sets expectation for the Facade.GetOrdersByIDs which will trigger the result defined by the following
// Then helper
func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) When(ctx context.Context, orderIDs []int64) *FacadeMockGetOrdersByIDsExpectation {
	if mmGetOrdersByIDs.mock.funcGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("FacadeMock.GetOrdersByIDs mock is already set by Set")
	}

	expectation := &FacadeMockGetOrdersByIDsExpectation{
		mock:               mmGetOrdersByIDs.mock,
		params:             &FacadeMockGetOrdersByIDsParams{ctx, orderIDs},
		expectationOrigins: FacadeMockGetOrdersByIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrdersByIDs.expectations = append(mmGetOrdersByIDs.expectations, expectation)
	return expectation
}

// Then sets up Facade.GetOrdersByIDs return parameters for the expectation previously defined by the When method
func (e *FacadeMockGetOrdersByIDsExpectation) Then(opa1 []*postgres.Order, err error) *FacadeMock {
	e.results = &FacadeMockGetOrdersByIDsResults{opa1, err}
	return e.mock
}

// Times sets number of times Facade.GetOrdersByIDs should be invoked
func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) Times(n uint64) *mFacadeMockGetOrdersByIDs {
	if n == 0 {
		mmGetOrdersByIDs.mock.t.Fatalf("Times of FacadeMock.GetOrdersByIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrdersByIDs.expectedInvocations, n)
	mmGetOrdersByIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByIDs
}

func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) invocationsDone() bool {
	if len(mmGetOrdersByIDs.expectations) == 0 && mmGetOrdersByIDs.defaultExpectation == nil && mmGetOrdersByIDs.mock.funcGetOrdersByIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrdersByIDs.mock.afterGetOrdersByIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrdersByIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrdersByIDs implements mm_app.Facade
func (mmGetOrdersByIDs *FacadeMock) GetOrdersByIDs(ctx context.Context, orderIDs []int64) (opa1 []*postgres.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrdersByIDs.beforeGetOrdersByIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrdersByIDs.afterGetOrdersByIDsCounter, 1)

	mmGetOrdersByIDs.t.Helper()

	if mmGetOrdersByIDs.inspectFuncGetOrdersByIDs != nil {
		mmGetOrdersByIDs.inspectFuncGetOrdersByIDs(ctx, orderIDs)
	}

	mm_params := FacadeMockGetOrdersByIDsParams{ctx, orderIDs}

	// Record call args
	mmGetOrdersByIDs.GetOrdersByIDsMock.mutex.Lock()
	mmGetOrdersByIDs.GetOrdersByIDsMock.callArgs = append(mmGetOrdersByIDs.GetOrdersByIDsMock.callArgs, &mm_params)
	mmGetOrdersByIDs.GetOrdersByIDsMock.mutex.Unlock()

	for _, e := range mmGetOrdersByIDs.GetOrdersByIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGetOrdersByIDsParams{ctx, orderIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrdersByIDs.t.Errorf("FacadeMock.GetOrdersByIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderIDs != nil && !minimock.Equal(*mm_want_ptrs.orderIDs, mm_got.orderIDs) {
				mmGetOrdersByIDs.t.Errorf("FacadeMock.GetOrdersByIDs got unexpected parameter orderIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.expectationOrigins.originOrderIDs, *mm_want_ptrs.orderIDs, mm_got.orderIDs, minimock.Diff(*mm_want_ptrs.orderIDs, mm_got.orderIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrdersByIDs.t.Errorf("FacadeMock.GetOrdersByIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrdersByIDs.t.Fatal("No results are set for the FacadeMock.GetOrdersByIDs")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmGetOrdersByIDs.funcGetOrdersByIDs != nil {
		return mmGetOrdersByIDs.funcGetOrdersByIDs(ctx, orderIDs)
	}
	mmGetOrdersByIDs.t.Fatalf("Unexpected call to FacadeMock.GetOrdersByIDs. %v %v", ctx, orderIDs)
	return
}

// GetOrdersByIDsAfterCounter returns a count of finished FacadeMock.GetOrdersByIDs invocations
func (mmGetOrdersByIDs *FacadeMock) GetOrdersByIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByIDs.afterGetOrdersByIDsCounter)
}

// GetOrdersByIDsBeforeCounter returns a count of FacadeMock.GetOrdersByIDs invocations
func (mmGetOrdersByIDs *FacadeMock) GetOrdersByIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByIDs.beforeGetOrdersByIDsCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GetOrdersByIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrdersByIDs *mFacadeMockGetOrdersByIDs) Calls() []*FacadeMockGetOrdersByIDsParams {
	mmGetOrdersByIDs.mutex.RLock()

	argCopy := make([]*FacadeMockGetOrdersByIDsParams, len(mmGetOrdersByIDs.callArgs))
	copy(argCopy, mmGetOrdersByIDs.callArgs)

	mmGetOrdersByIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersByIDsDone returns true if the count of the GetOrdersByIDs invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGetOrdersByIDsDone() bool {
	if m.GetOrdersByIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersByIDsMock.invocationsDone()
}

// MinimockGetOrdersByIDsInspect logs each unmet expectation
func (m *FacadeMock) MinimockGetOrdersByIDsInspect() {
	for _, e := range m.GetOrdersByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GetOrdersByIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersByIDsCounter := mm_atomic.LoadUint64(&m.afterGetOrdersByIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersByIDsMock.defaultExpectation != nil && afterGetOrdersByIDsCounter < 1 {
		if m.GetOrdersByIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GetOrdersByIDs at\n%s", m.GetOrdersByIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GetOrdersByIDs at\n%s with params: %#v", m.GetOrdersByIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersByIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrdersByIDs != nil && afterGetOrdersByIDsCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GetOrdersByIDs at\n%s", m.funcGetOrdersByIDsOrigin)
	}

	if !m.GetOrdersByIDsMock.invocationsDone() && afterGetOrdersByIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GetOrdersByIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersByIDsMock.expectedInvocations), m.GetOrdersByIDsMock.expectedInvocationsOrigin, afterGetOrdersByIDsCounter)
	}
}

type mFacadeMockGetReturns struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGetReturnsExpectation
	expectations       []*FacadeMockGetReturnsExpectation

	callArgs []*FacadeMockGetReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGetReturnsExpectation specifies expectation struct of the Facade.GetReturns
type FacadeMockGetReturnsExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGetReturnsParams
	paramPtrs          *FacadeMockGetReturnsParamPtrs
	expectationOrigins FacadeMockGetReturnsExpectationOrigins
	results            *FacadeMockGetReturnsResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGetReturnsParams contains parameters of the Facade.GetReturns
type FacadeMockGetReturnsParams struct {
	ctx context.Context
}

// FacadeMockGetReturnsParamPtrs contains pointers to parameters of the Facade.GetReturns
type FacadeMockGetReturnsParamPtrs struct {
	ctx *context.Context
}

// FacadeMockGetReturnsResults contains results of the Facade.GetReturns
type FacadeMockGetReturnsResults struct {
	opa1 []*postgres.Order
	err  error
}

// FacadeMockGetReturnsOrigins contains origins of expectations of the Facade.GetReturns
type FacadeMockGetReturnsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturns *mFacadeMockGetReturns) Optional() *mFacadeMockGetReturns {
	mmGetReturns.optional = true
	return mmGetReturns
}

// Expect sets up expected params for Facade.GetReturns
func (mmGetReturns *mFacadeMockGetReturns) Expect(ctx context.Context) *mFacadeMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("FacadeMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &FacadeMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.paramPtrs != nil {
		mmGetReturns.mock.t.Fatalf("FacadeMock.GetReturns mock is already set by ExpectParams functions")
	}

	mmGetReturns.defaultExpectation.params = &FacadeMockGetReturnsParams{ctx}
	mmGetReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReturns.expectations {
		if minimock.Equal(e.params, mmGetReturns.defaultExpectation.params) {
			mmGetReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReturns.defaultExpectation.params)
		}
	}

	return mmGetReturns
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GetReturns
func (mmGetReturns *mFacadeMockGetReturns) ExpectCtxParam1(ctx context.Context) *mFacadeMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("FacadeMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &FacadeMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.params != nil {
		mmGetReturns.mock.t.Fatalf("FacadeMock.GetReturns mock is already set by Expect")
	}

	if mmGetReturns.defaultExpectation.paramPtrs == nil {
		mmGetReturns.defaultExpectation.paramPtrs = &FacadeMockGetReturnsParamPtrs{}
	}
	mmGetReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReturns
}

// Inspect accepts an inspector function that has same arguments as the Facade.GetReturns
func (mmGetReturns *mFacadeMockGetReturns) Inspect(f func(ctx context.Context)) *mFacadeMockGetReturns {
	if mmGetReturns.mock.inspectFuncGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("Inspect function is already set for FacadeMock.GetReturns")
	}

	mmGetReturns.mock.inspectFuncGetReturns = f

	return mmGetReturns
}

// Return sets up results that will be returned by Facade.GetReturns
func (mmGetReturns *mFacadeMockGetReturns) Return(opa1 []*postgres.Order, err error) *FacadeMock {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("FacadeMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &FacadeMockGetReturnsExpectation{mock: mmGetReturns.mock}
	}
	mmGetReturns.defaultExpectation.results = &FacadeMockGetReturnsResults{opa1, err}
	mmGetReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReturns.mock
}

// Set uses given function f to mock the Facade.GetReturns method
func (mmGetReturns *mFacadeMockGetReturns) Set(f func(ctx context.Context) (opa1 []*postgres.Order, err error)) *FacadeMock {
	if mmGetReturns.defaultExpectation != nil {
		mmGetReturns.mock.t.Fatalf("Default expectation is already set for the Facade.GetReturns method")
	}

	if len(mmGetReturns.expectations) > 0 {
		mmGetReturns.mock.t.Fatalf("Some expectations are already set for the Facade.GetReturns method")
	}

	mmGetReturns.mock.funcGetReturns = f
	mmGetReturns.mock.funcGetReturnsOrigin = minimock.CallerInfo(1)
	return mmGetReturns.mock
}

// When sets expectation for the Facade.GetReturns which will trigger the result defined by the following
// Then helper
func (mmGetReturns *mFacadeMockGetReturns) When(ctx context.Context) *FacadeMockGetReturnsExpectation {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("FacadeMock.GetReturns mock is already set by Set")
	}

	expectation := &FacadeMockGetReturnsExpectation{
		mock:               mmGetReturns.mock,
		params:             &FacadeMockGetReturnsParams{ctx},
		expectationOrigins: FacadeMockGetReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReturns.expectations = append(mmGetReturns.expectations, expectation)
	return expectation
}

// Then sets up Facade.GetReturns return parameters for the expectation previously defined by the When method
func (e *FacadeMockGetReturnsExpectation) Then(opa1 []*postgres.Order, err error) *FacadeMock {
	e.results = &FacadeMockGetReturnsResults{opa1, err}
	return e.mock
}

// Times sets number of times Facade.GetReturns should be invoked
func (mmGetReturns *mFacadeMockGetReturns) Times(n uint64) *mFacadeMockGetReturns {
	if n == 0 {
		mmGetReturns.mock.t.Fatalf("Times of FacadeMock.GetReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReturns.expectedInvocations, n)
	mmGetReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReturns
}

func (mmGetReturns *mFacadeMockGetReturns) invocationsDone() bool {
	if len(mmGetReturns.expectations) == 0 && mmGetReturns.defaultExpectation == nil && mmGetReturns.mock.funcGetReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReturns.mock.afterGetReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReturns implements mm_app.Facade
func (mmGetReturns *FacadeMock) GetReturns(ctx context.Context) (opa1 []*postgres.Order, err error) {
	mm_atomic.AddUint64(&mmGetReturns.beforeGetReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReturns.afterGetReturnsCounter, 1)

	mmGetReturns.t.Helper()

	if mmGetReturns.inspectFuncGetReturns != nil {
		mmGetReturns.inspectFuncGetReturns(ctx)
	}

	mm_params := FacadeMockGetReturnsParams{ctx}

	// Record call args
	mmGetReturns.GetReturnsMock.mutex.Lock()
	mmGetReturns.GetReturnsMock.callArgs = append(mmGetReturns.GetReturnsMock.callArgs, &mm_params)
	mmGetReturns.GetReturnsMock.mutex.Unlock()

	for _, e := range mmGetReturns.GetReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmGetReturns.GetReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReturns.GetReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReturns.GetReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmGetReturns.GetReturnsMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGetReturnsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReturns.t.Errorf("FacadeMock.GetReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReturns.t.Errorf("FacadeMock.GetReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReturns.GetReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReturns.t.Fatal("No results are set for the FacadeMock.GetReturns")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmGetReturns.funcGetReturns != nil {
		return mmGetReturns.funcGetReturns(ctx)
	}
	mmGetReturns.t.Fatalf("Unexpected call to FacadeMock.GetReturns. %v", ctx)
	return
}

// GetReturnsAfterCounter returns a count of finished FacadeMock.GetReturns invocations
func (mmGetReturns *FacadeMock) GetReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturns.afterGetReturnsCounter)
}

// GetReturnsBeforeCounter returns a count of FacadeMock.GetReturns invocations
func (mmGetReturns *FacadeMock) GetReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturns.beforeGetReturnsCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GetReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReturns *mFacadeMockGetReturns) Calls() []*FacadeMockGetReturnsParams {
	mmGetReturns.mutex.RLock()

	argCopy := make([]*FacadeMockGetReturnsParams, len(mmGetReturns.callArgs))
	copy(argCopy, mmGetReturns.callArgs)

	mmGetReturns.mutex.RUnlock()

	return argCopy
}

// MinimockGetReturnsDone returns true if the count of the GetReturns invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGetReturnsDone() bool {
	if m.GetReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReturnsMock.invocationsDone()
}

// MinimockGetReturnsInspect logs each unmet expectation
func (m *FacadeMock) MinimockGetReturnsInspect() {
	for _, e := range m.GetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GetReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReturnsCounter := mm_atomic.LoadUint64(&m.afterGetReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReturnsMock.defaultExpectation != nil && afterGetReturnsCounter < 1 {
		if m.GetReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GetReturns at\n%s", m.GetReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GetReturns at\n%s with params: %#v", m.GetReturnsMock.defaultExpectation.expectationOrigins.origin, *m.GetReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReturns != nil && afterGetReturnsCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GetReturns at\n%s", m.funcGetReturnsOrigin)
	}

	if !m.GetReturnsMock.invocationsDone() && afterGetReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GetReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReturnsMock.expectedInvocations), m.GetReturnsMock.expectedInvocationsOrigin, afterGetReturnsCounter)
	}
}

type mFacadeMockGiveOrders struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGiveOrdersExpectation
	expectations       []*FacadeMockGiveOrdersExpectation

	callArgs []*FacadeMockGiveOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGiveOrdersExpectation specifies expectation struct of the Facade.GiveOrders
type FacadeMockGiveOrdersExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGiveOrdersParams
	paramPtrs          *FacadeMockGiveOrdersParamPtrs
	expectationOrigins FacadeMockGiveOrdersExpectationOrigins
	results            *FacadeMockGiveOrdersResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGiveOrdersParams contains parameters of the Facade.GiveOrders
type FacadeMockGiveOrdersParams struct {
	ctx      context.Context
	orderIDs []int64
}

// FacadeMockGiveOrdersParamPtrs contains pointers to parameters of the Facade.GiveOrders
type FacadeMockGiveOrdersParamPtrs struct {
	ctx      *context.Context
	orderIDs *[]int64
}

// FacadeMockGiveOrdersResults contains results of the Facade.GiveOrders
type FacadeMockGiveOrdersResults struct {
	err error
}

// FacadeMockGiveOrdersOrigins contains origins of expectations of the Facade.GiveOrders
type FacadeMockGiveOrdersExpectationOrigins struct {
	origin         string
	originCtx      string
	originOrderIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGiveOrders *mFacadeMockGiveOrders) Optional() *mFacadeMockGiveOrders {
	mmGiveOrders.optional = true
	return mmGiveOrders
}

// Expect sets up expected params for Facade.GiveOrders
func (mmGiveOrders *mFacadeMockGiveOrders) Expect(ctx context.Context, orderIDs []int64) *mFacadeMockGiveOrders {
	if mmGiveOrders.mock.funcGiveOrders != nil {
		mmGiveOrders.mock.t.Fatalf("FacadeMock.GiveOrders mock is already set by Set")
	}

	if mmGiveOrders.defaultExpectation == nil {
		mmGiveOrders.defaultExpectation = &FacadeMockGiveOrdersExpectation{}
	}

	if mmGiveOrders.defaultExpectation.paramPtrs != nil {
		mmGiveOrders.mock.t.Fatalf("FacadeMock.GiveOrders mock is already set by ExpectParams functions")
	}

	mmGiveOrders.defaultExpectation.params = &FacadeMockGiveOrdersParams{ctx, orderIDs}
	mmGiveOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGiveOrders.expectations {
		if minimock.Equal(e.params, mmGiveOrders.defaultExpectation.params) {
			mmGiveOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGiveOrders.defaultExpectation.params)
		}
	}

	return mmGiveOrders
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GiveOrders
func (mmGiveOrders *mFacadeMockGiveOrders) ExpectCtxParam1(ctx context.Context) *mFacadeMockGiveOrders {
	if mmGiveOrders.mock.funcGiveOrders != nil {
		mmGiveOrders.mock.t.Fatalf("FacadeMock.GiveOrders mock is already set by Set")
	}

	if mmGiveOrders.defaultExpectation == nil {
		mmGiveOrders.defaultExpectation = &FacadeMockGiveOrdersExpectation{}
	}

	if mmGiveOrders.defaultExpectation.params != nil {
		mmGiveOrders.mock.t.Fatalf("FacadeMock.GiveOrders mock is already set by Expect")
	}

	if mmGiveOrders.defaultExpectation.paramPtrs == nil {
		mmGiveOrders.defaultExpectation.paramPtrs = &FacadeMockGiveOrdersParamPtrs{}
	}
	mmGiveOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmGiveOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGiveOrders
}

// ExpectOrderIDsParam2 sets up expected param orderIDs for Facade.GiveOrders
func (mmGiveOrders *mFacadeMockGiveOrders) ExpectOrderIDsParam2(orderIDs []int64) *mFacadeMockGiveOrders {
	if mmGiveOrders.mock.funcGiveOrders != nil {
		mmGiveOrders.mock.t.Fatalf("FacadeMock.GiveOrders mock is already set by Set")
	}

	if mmGiveOrders.defaultExpectation == nil {
		mmGiveOrders.defaultExpectation = &FacadeMockGiveOrdersExpectation{}
	}

	if mmGiveOrders.defaultExpectation.params != nil {
		mmGiveOrders.mock.t.Fatalf("FacadeMock.GiveOrders mock is already set by Expect")
	}

	if mmGiveOrders.defaultExpectation.paramPtrs == nil {
		mmGiveOrders.defaultExpectation.paramPtrs = &FacadeMockGiveOrdersParamPtrs{}
	}
	mmGiveOrders.defaultExpectation.paramPtrs.orderIDs = &orderIDs
	mmGiveOrders.defaultExpectation.expectationOrigins.originOrderIDs = minimock.CallerInfo(1)

	return mmGiveOrders
}

// Inspect accepts an inspector function that has same arguments as the Facade.GiveOrders
func (mmGiveOrders *mFacadeMockGiveOrders) Inspect(f func(ctx context.Context, orderIDs []int64)) *mFacadeMockGiveOrders {
	if mmGiveOrders.mock.inspectFuncGiveOrders != nil {
		mmGiveOrders.mock.t.Fatalf("Inspect function is already set for FacadeMock.GiveOrders")
	}

	mmGiveOrders.mock.inspectFuncGiveOrders = f

	return mmGiveOrders
}

// Return sets up results that will be returned by Facade.GiveOrders
func (mmGiveOrders *mFacadeMockGiveOrders) Return(err error) *FacadeMock {
	if mmGiveOrders.mock.funcGiveOrders != nil {
		mmGiveOrders.mock.t.Fatalf("FacadeMock.GiveOrders mock is already set by Set")
	}

	if mmGiveOrders.defaultExpectation == nil {
		mmGiveOrders.defaultExpectation = &FacadeMockGiveOrdersExpectation{mock: mmGiveOrders.mock}
	}
	mmGiveOrders.defaultExpectation.results = &FacadeMockGiveOrdersResults{err}
	mmGiveOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGiveOrders.mock
}

// Set uses given function f to mock the Facade.GiveOrders method
func (mmGiveOrders *mFacadeMockGiveOrders) Set(f func(ctx context.Context, orderIDs []int64) (err error)) *FacadeMock {
	if mmGiveOrders.defaultExpectation != nil {
		mmGiveOrders.mock.t.Fatalf("Default expectation is already set for the Facade.GiveOrders method")
	}

	if len(mmGiveOrders.expectations) > 0 {
		mmGiveOrders.mock.t.Fatalf("Some expectations are already set for the Facade.GiveOrders method")
	}

	mmGiveOrders.mock.funcGiveOrders = f
	mmGiveOrders.mock.funcGiveOrdersOrigin = minimock.CallerInfo(1)
	return mmGiveOrders.mock
}

// When sets expectation for the Facade.GiveOrders which will trigger the result defined by the following
// Then helper
func (mmGiveOrders *mFacadeMockGiveOrders) When(ctx context.Context, orderIDs []int64) *FacadeMockGiveOrdersExpectation {
	if mmGiveOrders.mock.funcGiveOrders != nil {
		mmGiveOrders.mock.t.Fatalf("FacadeMock.GiveOrders mock is already set by Set")
	}

	expectation := &FacadeMockGiveOrdersExpectation{
		mock:               mmGiveOrders.mock,
		params:             &FacadeMockGiveOrdersParams{ctx, orderIDs},
		expectationOrigins: FacadeMockGiveOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGiveOrders.expectations = append(mmGiveOrders.expectations, expectation)
	return expectation
}

// Then sets up Facade.GiveOrders return parameters for the expectation previously defined by the When method
func (e *FacadeMockGiveOrdersExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockGiveOrdersResults{err}
	return e.mock
}

// Times sets number of times Facade.GiveOrders should be invoked
func (mmGiveOrders *mFacadeMockGiveOrders) Times(n uint64) *mFacadeMockGiveOrders {
	if n == 0 {
		mmGiveOrders.mock.t.Fatalf("Times of FacadeMock.GiveOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGiveOrders.expectedInvocations, n)
	mmGiveOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGiveOrders
}

func (mmGiveOrders *mFacadeMockGiveOrders) invocationsDone() bool {
	if len(mmGiveOrders.expectations) == 0 && mmGiveOrders.defaultExpectation == nil && mmGiveOrders.mock.funcGiveOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGiveOrders.mock.afterGiveOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGiveOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GiveOrders implements mm_app.Facade
func (mmGiveOrders *FacadeMock) GiveOrders(ctx context.Context, orderIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmGiveOrders.beforeGiveOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGiveOrders.afterGiveOrdersCounter, 1)

	mmGiveOrders.t.Helper()

	if mmGiveOrders.inspectFuncGiveOrders != nil {
		mmGiveOrders.inspectFuncGiveOrders(ctx, orderIDs)
	}

	mm_params := FacadeMockGiveOrdersParams{ctx, orderIDs}

	// Record call args
	mmGiveOrders.GiveOrdersMock.mutex.Lock()
	mmGiveOrders.GiveOrdersMock.callArgs = append(mmGiveOrders.GiveOrdersMock.callArgs, &mm_params)
	mmGiveOrders.GiveOrdersMock.mutex.Unlock()

	for _, e := range mmGiveOrders.GiveOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGiveOrders.GiveOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGiveOrders.GiveOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGiveOrders.GiveOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmGiveOrders.GiveOrdersMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGiveOrdersParams{ctx, orderIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGiveOrders.t.Errorf("FacadeMock.GiveOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGiveOrders.GiveOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderIDs != nil && !minimock.Equal(*mm_want_ptrs.orderIDs, mm_got.orderIDs) {
				mmGiveOrders.t.Errorf("FacadeMock.GiveOrders got unexpected parameter orderIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGiveOrders.GiveOrdersMock.defaultExpectation.expectationOrigins.originOrderIDs, *mm_want_ptrs.orderIDs, mm_got.orderIDs, minimock.Diff(*mm_want_ptrs.orderIDs, mm_got.orderIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGiveOrders.t.Errorf("FacadeMock.GiveOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGiveOrders.GiveOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGiveOrders.GiveOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGiveOrders.t.Fatal("No results are set for the FacadeMock.GiveOrders")
		}
		return (*mm_results).err
	}
	if mmGiveOrders.funcGiveOrders != nil {
		return mmGiveOrders.funcGiveOrders(ctx, orderIDs)
	}
	mmGiveOrders.t.Fatalf("Unexpected call to FacadeMock.GiveOrders. %v %v", ctx, orderIDs)
	return
}

// GiveOrdersAfterCounter returns a count of finished FacadeMock.GiveOrders invocations
func (mmGiveOrders *FacadeMock) GiveOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOrders.afterGiveOrdersCounter)
}

// GiveOrdersBeforeCounter returns a count of FacadeMock.GiveOrders invocations
func (mmGiveOrders *FacadeMock) GiveOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOrders.beforeGiveOrdersCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GiveOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGiveOrders *mFacadeMockGiveOrders) Calls() []*FacadeMockGiveOrdersParams {
	mmGiveOrders.mutex.RLock()

	argCopy := make([]*FacadeMockGiveOrdersParams, len(mmGiveOrders.callArgs))
	copy(argCopy, mmGiveOrders.callArgs)

	mmGiveOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGiveOrdersDone returns true if the count of the GiveOrders invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGiveOrdersDone() bool {
	if m.GiveOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GiveOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GiveOrdersMock.invocationsDone()
}

// MinimockGiveOrdersInspect logs each unmet expectation
func (m *FacadeMock) MinimockGiveOrdersInspect() {
	for _, e := range m.GiveOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GiveOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGiveOrdersCounter := mm_atomic.LoadUint64(&m.afterGiveOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GiveOrdersMock.defaultExpectation != nil && afterGiveOrdersCounter < 1 {
		if m.GiveOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GiveOrders at\n%s", m.GiveOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GiveOrders at\n%s with params: %#v", m.GiveOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GiveOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveOrders != nil && afterGiveOrdersCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GiveOrders at\n%s", m.funcGiveOrdersOrigin)
	}

	if !m.GiveOrdersMock.invocationsDone() && afterGiveOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GiveOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GiveOrdersMock.expectedInvocations), m.GiveOrdersMock.expectedInvocationsOrigin, afterGiveOrdersCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FacadeMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAcceptReturnInspect()

			m.MinimockAddOrderInspect()

			m.MinimockCheckOrderStatusInspect()

			m.MinimockDeleteOrderInspect()

			m.MinimockGetOrdersInspect()

			m.MinimockGetOrdersByIDsInspect()

			m.MinimockGetReturnsInspect()

			m.MinimockGiveOrdersInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FacadeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FacadeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcceptReturnDone() &&
		m.MinimockAddOrderDone() &&
		m.MinimockCheckOrderStatusDone() &&
		m.MinimockDeleteOrderDone() &&
		m.MinimockGetOrdersDone() &&
		m.MinimockGetOrdersByIDsDone() &&
		m.MinimockGetReturnsDone() &&
		m.MinimockGiveOrdersDone()
}
