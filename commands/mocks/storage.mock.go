// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

import (
	"homework/storage/json_file"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements mm_commands.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAcceptReturn          func(clientID int64, orderID int64) (err error)
	funcAcceptReturnOrigin    string
	inspectFuncAcceptReturn   func(clientID int64, orderID int64)
	afterAcceptReturnCounter  uint64
	beforeAcceptReturnCounter uint64
	AcceptReturnMock          mStorageMockAcceptReturn

	funcAddOrder          func(op1 *json_file.Order) (err error)
	funcAddOrderOrigin    string
	inspectFuncAddOrder   func(op1 *json_file.Order)
	afterAddOrderCounter  uint64
	beforeAddOrderCounter uint64
	AddOrderMock          mStorageMockAddOrder

	funcAddOrderToStory          func(orderID int64, path string) (err error)
	funcAddOrderToStoryOrigin    string
	inspectFuncAddOrderToStory   func(orderID int64, path string)
	afterAddOrderToStoryCounter  uint64
	beforeAddOrderToStoryCounter uint64
	AddOrderToStoryMock          mStorageMockAddOrderToStory

	funcCheckIfExists          func(orderID int64) (err error)
	funcCheckIfExistsOrigin    string
	inspectFuncCheckIfExists   func(orderID int64)
	afterCheckIfExistsCounter  uint64
	beforeCheckIfExistsCounter uint64
	CheckIfExistsMock          mStorageMockCheckIfExists

	funcDeleteOrderByID          func(i1 int64) (err error)
	funcDeleteOrderByIDOrigin    string
	inspectFuncDeleteOrderByID   func(i1 int64)
	afterDeleteOrderByIDCounter  uint64
	beforeDeleteOrderByIDCounter uint64
	DeleteOrderByIDMock          mStorageMockDeleteOrderByID

	funcGetAll          func() (m1 map[int64]*json_file.Order, err error)
	funcGetAllOrigin    string
	inspectFuncGetAll   func()
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mStorageMockGetAll

	funcGiveOrdersToClient          func(skuIDs []int64) (err error)
	funcGiveOrdersToClientOrigin    string
	inspectFuncGiveOrdersToClient   func(skuIDs []int64)
	afterGiveOrdersToClientCounter  uint64
	beforeGiveOrdersToClientCounter uint64
	GiveOrdersToClientMock          mStorageMockGiveOrdersToClient
}

// NewStorageMock returns a mock for mm_commands.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcceptReturnMock = mStorageMockAcceptReturn{mock: m}
	m.AcceptReturnMock.callArgs = []*StorageMockAcceptReturnParams{}

	m.AddOrderMock = mStorageMockAddOrder{mock: m}
	m.AddOrderMock.callArgs = []*StorageMockAddOrderParams{}

	m.AddOrderToStoryMock = mStorageMockAddOrderToStory{mock: m}
	m.AddOrderToStoryMock.callArgs = []*StorageMockAddOrderToStoryParams{}

	m.CheckIfExistsMock = mStorageMockCheckIfExists{mock: m}
	m.CheckIfExistsMock.callArgs = []*StorageMockCheckIfExistsParams{}

	m.DeleteOrderByIDMock = mStorageMockDeleteOrderByID{mock: m}
	m.DeleteOrderByIDMock.callArgs = []*StorageMockDeleteOrderByIDParams{}

	m.GetAllMock = mStorageMockGetAll{mock: m}

	m.GiveOrdersToClientMock = mStorageMockGiveOrdersToClient{mock: m}
	m.GiveOrdersToClientMock.callArgs = []*StorageMockGiveOrdersToClientParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockAcceptReturn struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockAcceptReturnExpectation
	expectations       []*StorageMockAcceptReturnExpectation

	callArgs []*StorageMockAcceptReturnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockAcceptReturnExpectation specifies expectation struct of the Storage.AcceptReturn
type StorageMockAcceptReturnExpectation struct {
	mock               *StorageMock
	params             *StorageMockAcceptReturnParams
	paramPtrs          *StorageMockAcceptReturnParamPtrs
	expectationOrigins StorageMockAcceptReturnExpectationOrigins
	results            *StorageMockAcceptReturnResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockAcceptReturnParams contains parameters of the Storage.AcceptReturn
type StorageMockAcceptReturnParams struct {
	clientID int64
	orderID  int64
}

// StorageMockAcceptReturnParamPtrs contains pointers to parameters of the Storage.AcceptReturn
type StorageMockAcceptReturnParamPtrs struct {
	clientID *int64
	orderID  *int64
}

// StorageMockAcceptReturnResults contains results of the Storage.AcceptReturn
type StorageMockAcceptReturnResults struct {
	err error
}

// StorageMockAcceptReturnOrigins contains origins of expectations of the Storage.AcceptReturn
type StorageMockAcceptReturnExpectationOrigins struct {
	origin         string
	originClientID string
	originOrderID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptReturn *mStorageMockAcceptReturn) Optional() *mStorageMockAcceptReturn {
	mmAcceptReturn.optional = true
	return mmAcceptReturn
}

// Expect sets up expected params for Storage.AcceptReturn
func (mmAcceptReturn *mStorageMockAcceptReturn) Expect(clientID int64, orderID int64) *mStorageMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("StorageMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &StorageMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs != nil {
		mmAcceptReturn.mock.t.Fatalf("StorageMock.AcceptReturn mock is already set by ExpectParams functions")
	}

	mmAcceptReturn.defaultExpectation.params = &StorageMockAcceptReturnParams{clientID, orderID}
	mmAcceptReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptReturn.expectations {
		if minimock.Equal(e.params, mmAcceptReturn.defaultExpectation.params) {
			mmAcceptReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptReturn.defaultExpectation.params)
		}
	}

	return mmAcceptReturn
}

// ExpectClientIDParam1 sets up expected param clientID for Storage.AcceptReturn
func (mmAcceptReturn *mStorageMockAcceptReturn) ExpectClientIDParam1(clientID int64) *mStorageMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("StorageMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &StorageMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.params != nil {
		mmAcceptReturn.mock.t.Fatalf("StorageMock.AcceptReturn mock is already set by Expect")
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs == nil {
		mmAcceptReturn.defaultExpectation.paramPtrs = &StorageMockAcceptReturnParamPtrs{}
	}
	mmAcceptReturn.defaultExpectation.paramPtrs.clientID = &clientID
	mmAcceptReturn.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmAcceptReturn
}

// ExpectOrderIDParam2 sets up expected param orderID for Storage.AcceptReturn
func (mmAcceptReturn *mStorageMockAcceptReturn) ExpectOrderIDParam2(orderID int64) *mStorageMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("StorageMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &StorageMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.params != nil {
		mmAcceptReturn.mock.t.Fatalf("StorageMock.AcceptReturn mock is already set by Expect")
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs == nil {
		mmAcceptReturn.defaultExpectation.paramPtrs = &StorageMockAcceptReturnParamPtrs{}
	}
	mmAcceptReturn.defaultExpectation.paramPtrs.orderID = &orderID
	mmAcceptReturn.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmAcceptReturn
}

// Inspect accepts an inspector function that has same arguments as the Storage.AcceptReturn
func (mmAcceptReturn *mStorageMockAcceptReturn) Inspect(f func(clientID int64, orderID int64)) *mStorageMockAcceptReturn {
	if mmAcceptReturn.mock.inspectFuncAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("Inspect function is already set for StorageMock.AcceptReturn")
	}

	mmAcceptReturn.mock.inspectFuncAcceptReturn = f

	return mmAcceptReturn
}

// Return sets up results that will be returned by Storage.AcceptReturn
func (mmAcceptReturn *mStorageMockAcceptReturn) Return(err error) *StorageMock {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("StorageMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &StorageMockAcceptReturnExpectation{mock: mmAcceptReturn.mock}
	}
	mmAcceptReturn.defaultExpectation.results = &StorageMockAcceptReturnResults{err}
	mmAcceptReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptReturn.mock
}

// Set uses given function f to mock the Storage.AcceptReturn method
func (mmAcceptReturn *mStorageMockAcceptReturn) Set(f func(clientID int64, orderID int64) (err error)) *StorageMock {
	if mmAcceptReturn.defaultExpectation != nil {
		mmAcceptReturn.mock.t.Fatalf("Default expectation is already set for the Storage.AcceptReturn method")
	}

	if len(mmAcceptReturn.expectations) > 0 {
		mmAcceptReturn.mock.t.Fatalf("Some expectations are already set for the Storage.AcceptReturn method")
	}

	mmAcceptReturn.mock.funcAcceptReturn = f
	mmAcceptReturn.mock.funcAcceptReturnOrigin = minimock.CallerInfo(1)
	return mmAcceptReturn.mock
}

// When sets expectation for the Storage.AcceptReturn which will trigger the result defined by the following
// Then helper
func (mmAcceptReturn *mStorageMockAcceptReturn) When(clientID int64, orderID int64) *StorageMockAcceptReturnExpectation {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("StorageMock.AcceptReturn mock is already set by Set")
	}

	expectation := &StorageMockAcceptReturnExpectation{
		mock:               mmAcceptReturn.mock,
		params:             &StorageMockAcceptReturnParams{clientID, orderID},
		expectationOrigins: StorageMockAcceptReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptReturn.expectations = append(mmAcceptReturn.expectations, expectation)
	return expectation
}

// Then sets up Storage.AcceptReturn return parameters for the expectation previously defined by the When method
func (e *StorageMockAcceptReturnExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockAcceptReturnResults{err}
	return e.mock
}

// Times sets number of times Storage.AcceptReturn should be invoked
func (mmAcceptReturn *mStorageMockAcceptReturn) Times(n uint64) *mStorageMockAcceptReturn {
	if n == 0 {
		mmAcceptReturn.mock.t.Fatalf("Times of StorageMock.AcceptReturn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptReturn.expectedInvocations, n)
	mmAcceptReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptReturn
}

func (mmAcceptReturn *mStorageMockAcceptReturn) invocationsDone() bool {
	if len(mmAcceptReturn.expectations) == 0 && mmAcceptReturn.defaultExpectation == nil && mmAcceptReturn.mock.funcAcceptReturn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptReturn.mock.afterAcceptReturnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptReturn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptReturn implements mm_commands.Storage
func (mmAcceptReturn *StorageMock) AcceptReturn(clientID int64, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmAcceptReturn.beforeAcceptReturnCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptReturn.afterAcceptReturnCounter, 1)

	mmAcceptReturn.t.Helper()

	if mmAcceptReturn.inspectFuncAcceptReturn != nil {
		mmAcceptReturn.inspectFuncAcceptReturn(clientID, orderID)
	}

	mm_params := StorageMockAcceptReturnParams{clientID, orderID}

	// Record call args
	mmAcceptReturn.AcceptReturnMock.mutex.Lock()
	mmAcceptReturn.AcceptReturnMock.callArgs = append(mmAcceptReturn.AcceptReturnMock.callArgs, &mm_params)
	mmAcceptReturn.AcceptReturnMock.mutex.Unlock()

	for _, e := range mmAcceptReturn.AcceptReturnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAcceptReturn.AcceptReturnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptReturn.AcceptReturnMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptReturn.AcceptReturnMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptReturn.AcceptReturnMock.defaultExpectation.paramPtrs

		mm_got := StorageMockAcceptReturnParams{clientID, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmAcceptReturn.t.Errorf("StorageMock.AcceptReturn got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmAcceptReturn.t.Errorf("StorageMock.AcceptReturn got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptReturn.t.Errorf("StorageMock.AcceptReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptReturn.AcceptReturnMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptReturn.t.Fatal("No results are set for the StorageMock.AcceptReturn")
		}
		return (*mm_results).err
	}
	if mmAcceptReturn.funcAcceptReturn != nil {
		return mmAcceptReturn.funcAcceptReturn(clientID, orderID)
	}
	mmAcceptReturn.t.Fatalf("Unexpected call to StorageMock.AcceptReturn. %v %v", clientID, orderID)
	return
}

// AcceptReturnAfterCounter returns a count of finished StorageMock.AcceptReturn invocations
func (mmAcceptReturn *StorageMock) AcceptReturnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptReturn.afterAcceptReturnCounter)
}

// AcceptReturnBeforeCounter returns a count of StorageMock.AcceptReturn invocations
func (mmAcceptReturn *StorageMock) AcceptReturnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptReturn.beforeAcceptReturnCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.AcceptReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptReturn *mStorageMockAcceptReturn) Calls() []*StorageMockAcceptReturnParams {
	mmAcceptReturn.mutex.RLock()

	argCopy := make([]*StorageMockAcceptReturnParams, len(mmAcceptReturn.callArgs))
	copy(argCopy, mmAcceptReturn.callArgs)

	mmAcceptReturn.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptReturnDone returns true if the count of the AcceptReturn invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAcceptReturnDone() bool {
	if m.AcceptReturnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptReturnMock.invocationsDone()
}

// MinimockAcceptReturnInspect logs each unmet expectation
func (m *StorageMock) MinimockAcceptReturnInspect() {
	for _, e := range m.AcceptReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.AcceptReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptReturnCounter := mm_atomic.LoadUint64(&m.afterAcceptReturnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptReturnMock.defaultExpectation != nil && afterAcceptReturnCounter < 1 {
		if m.AcceptReturnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.AcceptReturn at\n%s", m.AcceptReturnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.AcceptReturn at\n%s with params: %#v", m.AcceptReturnMock.defaultExpectation.expectationOrigins.origin, *m.AcceptReturnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptReturn != nil && afterAcceptReturnCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.AcceptReturn at\n%s", m.funcAcceptReturnOrigin)
	}

	if !m.AcceptReturnMock.invocationsDone() && afterAcceptReturnCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.AcceptReturn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptReturnMock.expectedInvocations), m.AcceptReturnMock.expectedInvocationsOrigin, afterAcceptReturnCounter)
	}
}

type mStorageMockAddOrder struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockAddOrderExpectation
	expectations       []*StorageMockAddOrderExpectation

	callArgs []*StorageMockAddOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockAddOrderExpectation specifies expectation struct of the Storage.AddOrder
type StorageMockAddOrderExpectation struct {
	mock               *StorageMock
	params             *StorageMockAddOrderParams
	paramPtrs          *StorageMockAddOrderParamPtrs
	expectationOrigins StorageMockAddOrderExpectationOrigins
	results            *StorageMockAddOrderResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockAddOrderParams contains parameters of the Storage.AddOrder
type StorageMockAddOrderParams struct {
	op1 *json_file.Order
}

// StorageMockAddOrderParamPtrs contains pointers to parameters of the Storage.AddOrder
type StorageMockAddOrderParamPtrs struct {
	op1 **json_file.Order
}

// StorageMockAddOrderResults contains results of the Storage.AddOrder
type StorageMockAddOrderResults struct {
	err error
}

// StorageMockAddOrderOrigins contains origins of expectations of the Storage.AddOrder
type StorageMockAddOrderExpectationOrigins struct {
	origin    string
	originOp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrder *mStorageMockAddOrder) Optional() *mStorageMockAddOrder {
	mmAddOrder.optional = true
	return mmAddOrder
}

// Expect sets up expected params for Storage.AddOrder
func (mmAddOrder *mStorageMockAddOrder) Expect(op1 *json_file.Order) *mStorageMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("StorageMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &StorageMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.paramPtrs != nil {
		mmAddOrder.mock.t.Fatalf("StorageMock.AddOrder mock is already set by ExpectParams functions")
	}

	mmAddOrder.defaultExpectation.params = &StorageMockAddOrderParams{op1}
	mmAddOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrder.expectations {
		if minimock.Equal(e.params, mmAddOrder.defaultExpectation.params) {
			mmAddOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrder.defaultExpectation.params)
		}
	}

	return mmAddOrder
}

// ExpectOp1Param1 sets up expected param op1 for Storage.AddOrder
func (mmAddOrder *mStorageMockAddOrder) ExpectOp1Param1(op1 *json_file.Order) *mStorageMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("StorageMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &StorageMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("StorageMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &StorageMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.op1 = &op1
	mmAddOrder.defaultExpectation.expectationOrigins.originOp1 = minimock.CallerInfo(1)

	return mmAddOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.AddOrder
func (mmAddOrder *mStorageMockAddOrder) Inspect(f func(op1 *json_file.Order)) *mStorageMockAddOrder {
	if mmAddOrder.mock.inspectFuncAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("Inspect function is already set for StorageMock.AddOrder")
	}

	mmAddOrder.mock.inspectFuncAddOrder = f

	return mmAddOrder
}

// Return sets up results that will be returned by Storage.AddOrder
func (mmAddOrder *mStorageMockAddOrder) Return(err error) *StorageMock {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("StorageMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &StorageMockAddOrderExpectation{mock: mmAddOrder.mock}
	}
	mmAddOrder.defaultExpectation.results = &StorageMockAddOrderResults{err}
	mmAddOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// Set uses given function f to mock the Storage.AddOrder method
func (mmAddOrder *mStorageMockAddOrder) Set(f func(op1 *json_file.Order) (err error)) *StorageMock {
	if mmAddOrder.defaultExpectation != nil {
		mmAddOrder.mock.t.Fatalf("Default expectation is already set for the Storage.AddOrder method")
	}

	if len(mmAddOrder.expectations) > 0 {
		mmAddOrder.mock.t.Fatalf("Some expectations are already set for the Storage.AddOrder method")
	}

	mmAddOrder.mock.funcAddOrder = f
	mmAddOrder.mock.funcAddOrderOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// When sets expectation for the Storage.AddOrder which will trigger the result defined by the following
// Then helper
func (mmAddOrder *mStorageMockAddOrder) When(op1 *json_file.Order) *StorageMockAddOrderExpectation {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("StorageMock.AddOrder mock is already set by Set")
	}

	expectation := &StorageMockAddOrderExpectation{
		mock:               mmAddOrder.mock,
		params:             &StorageMockAddOrderParams{op1},
		expectationOrigins: StorageMockAddOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrder.expectations = append(mmAddOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.AddOrder return parameters for the expectation previously defined by the When method
func (e *StorageMockAddOrderExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockAddOrderResults{err}
	return e.mock
}

// Times sets number of times Storage.AddOrder should be invoked
func (mmAddOrder *mStorageMockAddOrder) Times(n uint64) *mStorageMockAddOrder {
	if n == 0 {
		mmAddOrder.mock.t.Fatalf("Times of StorageMock.AddOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrder.expectedInvocations, n)
	mmAddOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrder
}

func (mmAddOrder *mStorageMockAddOrder) invocationsDone() bool {
	if len(mmAddOrder.expectations) == 0 && mmAddOrder.defaultExpectation == nil && mmAddOrder.mock.funcAddOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrder.mock.afterAddOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrder implements mm_commands.Storage
func (mmAddOrder *StorageMock) AddOrder(op1 *json_file.Order) (err error) {
	mm_atomic.AddUint64(&mmAddOrder.beforeAddOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrder.afterAddOrderCounter, 1)

	mmAddOrder.t.Helper()

	if mmAddOrder.inspectFuncAddOrder != nil {
		mmAddOrder.inspectFuncAddOrder(op1)
	}

	mm_params := StorageMockAddOrderParams{op1}

	// Record call args
	mmAddOrder.AddOrderMock.mutex.Lock()
	mmAddOrder.AddOrderMock.callArgs = append(mmAddOrder.AddOrderMock.callArgs, &mm_params)
	mmAddOrder.AddOrderMock.mutex.Unlock()

	for _, e := range mmAddOrder.AddOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOrder.AddOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrder.AddOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrder.AddOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrder.AddOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageMockAddOrderParams{op1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.op1 != nil && !minimock.Equal(*mm_want_ptrs.op1, mm_got.op1) {
				mmAddOrder.t.Errorf("StorageMock.AddOrder got unexpected parameter op1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originOp1, *mm_want_ptrs.op1, mm_got.op1, minimock.Diff(*mm_want_ptrs.op1, mm_got.op1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrder.t.Errorf("StorageMock.AddOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrder.AddOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrder.t.Fatal("No results are set for the StorageMock.AddOrder")
		}
		return (*mm_results).err
	}
	if mmAddOrder.funcAddOrder != nil {
		return mmAddOrder.funcAddOrder(op1)
	}
	mmAddOrder.t.Fatalf("Unexpected call to StorageMock.AddOrder. %v", op1)
	return
}

// AddOrderAfterCounter returns a count of finished StorageMock.AddOrder invocations
func (mmAddOrder *StorageMock) AddOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.afterAddOrderCounter)
}

// AddOrderBeforeCounter returns a count of StorageMock.AddOrder invocations
func (mmAddOrder *StorageMock) AddOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.beforeAddOrderCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.AddOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrder *mStorageMockAddOrder) Calls() []*StorageMockAddOrderParams {
	mmAddOrder.mutex.RLock()

	argCopy := make([]*StorageMockAddOrderParams, len(mmAddOrder.callArgs))
	copy(argCopy, mmAddOrder.callArgs)

	mmAddOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderDone returns true if the count of the AddOrder invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAddOrderDone() bool {
	if m.AddOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderMock.invocationsDone()
}

// MinimockAddOrderInspect logs each unmet expectation
func (m *StorageMock) MinimockAddOrderInspect() {
	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.AddOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderCounter := mm_atomic.LoadUint64(&m.afterAddOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderMock.defaultExpectation != nil && afterAddOrderCounter < 1 {
		if m.AddOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.AddOrder at\n%s", m.AddOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.AddOrder at\n%s with params: %#v", m.AddOrderMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrder != nil && afterAddOrderCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.AddOrder at\n%s", m.funcAddOrderOrigin)
	}

	if !m.AddOrderMock.invocationsDone() && afterAddOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.AddOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderMock.expectedInvocations), m.AddOrderMock.expectedInvocationsOrigin, afterAddOrderCounter)
	}
}

type mStorageMockAddOrderToStory struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockAddOrderToStoryExpectation
	expectations       []*StorageMockAddOrderToStoryExpectation

	callArgs []*StorageMockAddOrderToStoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockAddOrderToStoryExpectation specifies expectation struct of the Storage.AddOrderToStory
type StorageMockAddOrderToStoryExpectation struct {
	mock               *StorageMock
	params             *StorageMockAddOrderToStoryParams
	paramPtrs          *StorageMockAddOrderToStoryParamPtrs
	expectationOrigins StorageMockAddOrderToStoryExpectationOrigins
	results            *StorageMockAddOrderToStoryResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockAddOrderToStoryParams contains parameters of the Storage.AddOrderToStory
type StorageMockAddOrderToStoryParams struct {
	orderID int64
	path    string
}

// StorageMockAddOrderToStoryParamPtrs contains pointers to parameters of the Storage.AddOrderToStory
type StorageMockAddOrderToStoryParamPtrs struct {
	orderID *int64
	path    *string
}

// StorageMockAddOrderToStoryResults contains results of the Storage.AddOrderToStory
type StorageMockAddOrderToStoryResults struct {
	err error
}

// StorageMockAddOrderToStoryOrigins contains origins of expectations of the Storage.AddOrderToStory
type StorageMockAddOrderToStoryExpectationOrigins struct {
	origin        string
	originOrderID string
	originPath    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrderToStory *mStorageMockAddOrderToStory) Optional() *mStorageMockAddOrderToStory {
	mmAddOrderToStory.optional = true
	return mmAddOrderToStory
}

// Expect sets up expected params for Storage.AddOrderToStory
func (mmAddOrderToStory *mStorageMockAddOrderToStory) Expect(orderID int64, path string) *mStorageMockAddOrderToStory {
	if mmAddOrderToStory.mock.funcAddOrderToStory != nil {
		mmAddOrderToStory.mock.t.Fatalf("StorageMock.AddOrderToStory mock is already set by Set")
	}

	if mmAddOrderToStory.defaultExpectation == nil {
		mmAddOrderToStory.defaultExpectation = &StorageMockAddOrderToStoryExpectation{}
	}

	if mmAddOrderToStory.defaultExpectation.paramPtrs != nil {
		mmAddOrderToStory.mock.t.Fatalf("StorageMock.AddOrderToStory mock is already set by ExpectParams functions")
	}

	mmAddOrderToStory.defaultExpectation.params = &StorageMockAddOrderToStoryParams{orderID, path}
	mmAddOrderToStory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrderToStory.expectations {
		if minimock.Equal(e.params, mmAddOrderToStory.defaultExpectation.params) {
			mmAddOrderToStory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrderToStory.defaultExpectation.params)
		}
	}

	return mmAddOrderToStory
}

// ExpectOrderIDParam1 sets up expected param orderID for Storage.AddOrderToStory
func (mmAddOrderToStory *mStorageMockAddOrderToStory) ExpectOrderIDParam1(orderID int64) *mStorageMockAddOrderToStory {
	if mmAddOrderToStory.mock.funcAddOrderToStory != nil {
		mmAddOrderToStory.mock.t.Fatalf("StorageMock.AddOrderToStory mock is already set by Set")
	}

	if mmAddOrderToStory.defaultExpectation == nil {
		mmAddOrderToStory.defaultExpectation = &StorageMockAddOrderToStoryExpectation{}
	}

	if mmAddOrderToStory.defaultExpectation.params != nil {
		mmAddOrderToStory.mock.t.Fatalf("StorageMock.AddOrderToStory mock is already set by Expect")
	}

	if mmAddOrderToStory.defaultExpectation.paramPtrs == nil {
		mmAddOrderToStory.defaultExpectation.paramPtrs = &StorageMockAddOrderToStoryParamPtrs{}
	}
	mmAddOrderToStory.defaultExpectation.paramPtrs.orderID = &orderID
	mmAddOrderToStory.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmAddOrderToStory
}

// ExpectPathParam2 sets up expected param path for Storage.AddOrderToStory
func (mmAddOrderToStory *mStorageMockAddOrderToStory) ExpectPathParam2(path string) *mStorageMockAddOrderToStory {
	if mmAddOrderToStory.mock.funcAddOrderToStory != nil {
		mmAddOrderToStory.mock.t.Fatalf("StorageMock.AddOrderToStory mock is already set by Set")
	}

	if mmAddOrderToStory.defaultExpectation == nil {
		mmAddOrderToStory.defaultExpectation = &StorageMockAddOrderToStoryExpectation{}
	}

	if mmAddOrderToStory.defaultExpectation.params != nil {
		mmAddOrderToStory.mock.t.Fatalf("StorageMock.AddOrderToStory mock is already set by Expect")
	}

	if mmAddOrderToStory.defaultExpectation.paramPtrs == nil {
		mmAddOrderToStory.defaultExpectation.paramPtrs = &StorageMockAddOrderToStoryParamPtrs{}
	}
	mmAddOrderToStory.defaultExpectation.paramPtrs.path = &path
	mmAddOrderToStory.defaultExpectation.expectationOrigins.originPath = minimock.CallerInfo(1)

	return mmAddOrderToStory
}

// Inspect accepts an inspector function that has same arguments as the Storage.AddOrderToStory
func (mmAddOrderToStory *mStorageMockAddOrderToStory) Inspect(f func(orderID int64, path string)) *mStorageMockAddOrderToStory {
	if mmAddOrderToStory.mock.inspectFuncAddOrderToStory != nil {
		mmAddOrderToStory.mock.t.Fatalf("Inspect function is already set for StorageMock.AddOrderToStory")
	}

	mmAddOrderToStory.mock.inspectFuncAddOrderToStory = f

	return mmAddOrderToStory
}

// Return sets up results that will be returned by Storage.AddOrderToStory
func (mmAddOrderToStory *mStorageMockAddOrderToStory) Return(err error) *StorageMock {
	if mmAddOrderToStory.mock.funcAddOrderToStory != nil {
		mmAddOrderToStory.mock.t.Fatalf("StorageMock.AddOrderToStory mock is already set by Set")
	}

	if mmAddOrderToStory.defaultExpectation == nil {
		mmAddOrderToStory.defaultExpectation = &StorageMockAddOrderToStoryExpectation{mock: mmAddOrderToStory.mock}
	}
	mmAddOrderToStory.defaultExpectation.results = &StorageMockAddOrderToStoryResults{err}
	mmAddOrderToStory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrderToStory.mock
}

// Set uses given function f to mock the Storage.AddOrderToStory method
func (mmAddOrderToStory *mStorageMockAddOrderToStory) Set(f func(orderID int64, path string) (err error)) *StorageMock {
	if mmAddOrderToStory.defaultExpectation != nil {
		mmAddOrderToStory.mock.t.Fatalf("Default expectation is already set for the Storage.AddOrderToStory method")
	}

	if len(mmAddOrderToStory.expectations) > 0 {
		mmAddOrderToStory.mock.t.Fatalf("Some expectations are already set for the Storage.AddOrderToStory method")
	}

	mmAddOrderToStory.mock.funcAddOrderToStory = f
	mmAddOrderToStory.mock.funcAddOrderToStoryOrigin = minimock.CallerInfo(1)
	return mmAddOrderToStory.mock
}

// When sets expectation for the Storage.AddOrderToStory which will trigger the result defined by the following
// Then helper
func (mmAddOrderToStory *mStorageMockAddOrderToStory) When(orderID int64, path string) *StorageMockAddOrderToStoryExpectation {
	if mmAddOrderToStory.mock.funcAddOrderToStory != nil {
		mmAddOrderToStory.mock.t.Fatalf("StorageMock.AddOrderToStory mock is already set by Set")
	}

	expectation := &StorageMockAddOrderToStoryExpectation{
		mock:               mmAddOrderToStory.mock,
		params:             &StorageMockAddOrderToStoryParams{orderID, path},
		expectationOrigins: StorageMockAddOrderToStoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrderToStory.expectations = append(mmAddOrderToStory.expectations, expectation)
	return expectation
}

// Then sets up Storage.AddOrderToStory return parameters for the expectation previously defined by the When method
func (e *StorageMockAddOrderToStoryExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockAddOrderToStoryResults{err}
	return e.mock
}

// Times sets number of times Storage.AddOrderToStory should be invoked
func (mmAddOrderToStory *mStorageMockAddOrderToStory) Times(n uint64) *mStorageMockAddOrderToStory {
	if n == 0 {
		mmAddOrderToStory.mock.t.Fatalf("Times of StorageMock.AddOrderToStory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrderToStory.expectedInvocations, n)
	mmAddOrderToStory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrderToStory
}

func (mmAddOrderToStory *mStorageMockAddOrderToStory) invocationsDone() bool {
	if len(mmAddOrderToStory.expectations) == 0 && mmAddOrderToStory.defaultExpectation == nil && mmAddOrderToStory.mock.funcAddOrderToStory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrderToStory.mock.afterAddOrderToStoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrderToStory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrderToStory implements mm_commands.Storage
func (mmAddOrderToStory *StorageMock) AddOrderToStory(orderID int64, path string) (err error) {
	mm_atomic.AddUint64(&mmAddOrderToStory.beforeAddOrderToStoryCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrderToStory.afterAddOrderToStoryCounter, 1)

	mmAddOrderToStory.t.Helper()

	if mmAddOrderToStory.inspectFuncAddOrderToStory != nil {
		mmAddOrderToStory.inspectFuncAddOrderToStory(orderID, path)
	}

	mm_params := StorageMockAddOrderToStoryParams{orderID, path}

	// Record call args
	mmAddOrderToStory.AddOrderToStoryMock.mutex.Lock()
	mmAddOrderToStory.AddOrderToStoryMock.callArgs = append(mmAddOrderToStory.AddOrderToStoryMock.callArgs, &mm_params)
	mmAddOrderToStory.AddOrderToStoryMock.mutex.Unlock()

	for _, e := range mmAddOrderToStory.AddOrderToStoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOrderToStory.AddOrderToStoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrderToStory.AddOrderToStoryMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrderToStory.AddOrderToStoryMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrderToStory.AddOrderToStoryMock.defaultExpectation.paramPtrs

		mm_got := StorageMockAddOrderToStoryParams{orderID, path}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmAddOrderToStory.t.Errorf("StorageMock.AddOrderToStory got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrderToStory.AddOrderToStoryMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.path != nil && !minimock.Equal(*mm_want_ptrs.path, mm_got.path) {
				mmAddOrderToStory.t.Errorf("StorageMock.AddOrderToStory got unexpected parameter path, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrderToStory.AddOrderToStoryMock.defaultExpectation.expectationOrigins.originPath, *mm_want_ptrs.path, mm_got.path, minimock.Diff(*mm_want_ptrs.path, mm_got.path))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrderToStory.t.Errorf("StorageMock.AddOrderToStory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrderToStory.AddOrderToStoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrderToStory.AddOrderToStoryMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrderToStory.t.Fatal("No results are set for the StorageMock.AddOrderToStory")
		}
		return (*mm_results).err
	}
	if mmAddOrderToStory.funcAddOrderToStory != nil {
		return mmAddOrderToStory.funcAddOrderToStory(orderID, path)
	}
	mmAddOrderToStory.t.Fatalf("Unexpected call to StorageMock.AddOrderToStory. %v %v", orderID, path)
	return
}

// AddOrderToStoryAfterCounter returns a count of finished StorageMock.AddOrderToStory invocations
func (mmAddOrderToStory *StorageMock) AddOrderToStoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrderToStory.afterAddOrderToStoryCounter)
}

// AddOrderToStoryBeforeCounter returns a count of StorageMock.AddOrderToStory invocations
func (mmAddOrderToStory *StorageMock) AddOrderToStoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrderToStory.beforeAddOrderToStoryCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.AddOrderToStory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrderToStory *mStorageMockAddOrderToStory) Calls() []*StorageMockAddOrderToStoryParams {
	mmAddOrderToStory.mutex.RLock()

	argCopy := make([]*StorageMockAddOrderToStoryParams, len(mmAddOrderToStory.callArgs))
	copy(argCopy, mmAddOrderToStory.callArgs)

	mmAddOrderToStory.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderToStoryDone returns true if the count of the AddOrderToStory invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAddOrderToStoryDone() bool {
	if m.AddOrderToStoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderToStoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderToStoryMock.invocationsDone()
}

// MinimockAddOrderToStoryInspect logs each unmet expectation
func (m *StorageMock) MinimockAddOrderToStoryInspect() {
	for _, e := range m.AddOrderToStoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.AddOrderToStory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderToStoryCounter := mm_atomic.LoadUint64(&m.afterAddOrderToStoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderToStoryMock.defaultExpectation != nil && afterAddOrderToStoryCounter < 1 {
		if m.AddOrderToStoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.AddOrderToStory at\n%s", m.AddOrderToStoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.AddOrderToStory at\n%s with params: %#v", m.AddOrderToStoryMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderToStoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrderToStory != nil && afterAddOrderToStoryCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.AddOrderToStory at\n%s", m.funcAddOrderToStoryOrigin)
	}

	if !m.AddOrderToStoryMock.invocationsDone() && afterAddOrderToStoryCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.AddOrderToStory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderToStoryMock.expectedInvocations), m.AddOrderToStoryMock.expectedInvocationsOrigin, afterAddOrderToStoryCounter)
	}
}

type mStorageMockCheckIfExists struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCheckIfExistsExpectation
	expectations       []*StorageMockCheckIfExistsExpectation

	callArgs []*StorageMockCheckIfExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCheckIfExistsExpectation specifies expectation struct of the Storage.CheckIfExists
type StorageMockCheckIfExistsExpectation struct {
	mock               *StorageMock
	params             *StorageMockCheckIfExistsParams
	paramPtrs          *StorageMockCheckIfExistsParamPtrs
	expectationOrigins StorageMockCheckIfExistsExpectationOrigins
	results            *StorageMockCheckIfExistsResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockCheckIfExistsParams contains parameters of the Storage.CheckIfExists
type StorageMockCheckIfExistsParams struct {
	orderID int64
}

// StorageMockCheckIfExistsParamPtrs contains pointers to parameters of the Storage.CheckIfExists
type StorageMockCheckIfExistsParamPtrs struct {
	orderID *int64
}

// StorageMockCheckIfExistsResults contains results of the Storage.CheckIfExists
type StorageMockCheckIfExistsResults struct {
	err error
}

// StorageMockCheckIfExistsOrigins contains origins of expectations of the Storage.CheckIfExists
type StorageMockCheckIfExistsExpectationOrigins struct {
	origin        string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckIfExists *mStorageMockCheckIfExists) Optional() *mStorageMockCheckIfExists {
	mmCheckIfExists.optional = true
	return mmCheckIfExists
}

// Expect sets up expected params for Storage.CheckIfExists
func (mmCheckIfExists *mStorageMockCheckIfExists) Expect(orderID int64) *mStorageMockCheckIfExists {
	if mmCheckIfExists.mock.funcCheckIfExists != nil {
		mmCheckIfExists.mock.t.Fatalf("StorageMock.CheckIfExists mock is already set by Set")
	}

	if mmCheckIfExists.defaultExpectation == nil {
		mmCheckIfExists.defaultExpectation = &StorageMockCheckIfExistsExpectation{}
	}

	if mmCheckIfExists.defaultExpectation.paramPtrs != nil {
		mmCheckIfExists.mock.t.Fatalf("StorageMock.CheckIfExists mock is already set by ExpectParams functions")
	}

	mmCheckIfExists.defaultExpectation.params = &StorageMockCheckIfExistsParams{orderID}
	mmCheckIfExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckIfExists.expectations {
		if minimock.Equal(e.params, mmCheckIfExists.defaultExpectation.params) {
			mmCheckIfExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckIfExists.defaultExpectation.params)
		}
	}

	return mmCheckIfExists
}

// ExpectOrderIDParam1 sets up expected param orderID for Storage.CheckIfExists
func (mmCheckIfExists *mStorageMockCheckIfExists) ExpectOrderIDParam1(orderID int64) *mStorageMockCheckIfExists {
	if mmCheckIfExists.mock.funcCheckIfExists != nil {
		mmCheckIfExists.mock.t.Fatalf("StorageMock.CheckIfExists mock is already set by Set")
	}

	if mmCheckIfExists.defaultExpectation == nil {
		mmCheckIfExists.defaultExpectation = &StorageMockCheckIfExistsExpectation{}
	}

	if mmCheckIfExists.defaultExpectation.params != nil {
		mmCheckIfExists.mock.t.Fatalf("StorageMock.CheckIfExists mock is already set by Expect")
	}

	if mmCheckIfExists.defaultExpectation.paramPtrs == nil {
		mmCheckIfExists.defaultExpectation.paramPtrs = &StorageMockCheckIfExistsParamPtrs{}
	}
	mmCheckIfExists.defaultExpectation.paramPtrs.orderID = &orderID
	mmCheckIfExists.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmCheckIfExists
}

// Inspect accepts an inspector function that has same arguments as the Storage.CheckIfExists
func (mmCheckIfExists *mStorageMockCheckIfExists) Inspect(f func(orderID int64)) *mStorageMockCheckIfExists {
	if mmCheckIfExists.mock.inspectFuncCheckIfExists != nil {
		mmCheckIfExists.mock.t.Fatalf("Inspect function is already set for StorageMock.CheckIfExists")
	}

	mmCheckIfExists.mock.inspectFuncCheckIfExists = f

	return mmCheckIfExists
}

// Return sets up results that will be returned by Storage.CheckIfExists
func (mmCheckIfExists *mStorageMockCheckIfExists) Return(err error) *StorageMock {
	if mmCheckIfExists.mock.funcCheckIfExists != nil {
		mmCheckIfExists.mock.t.Fatalf("StorageMock.CheckIfExists mock is already set by Set")
	}

	if mmCheckIfExists.defaultExpectation == nil {
		mmCheckIfExists.defaultExpectation = &StorageMockCheckIfExistsExpectation{mock: mmCheckIfExists.mock}
	}
	mmCheckIfExists.defaultExpectation.results = &StorageMockCheckIfExistsResults{err}
	mmCheckIfExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckIfExists.mock
}

// Set uses given function f to mock the Storage.CheckIfExists method
func (mmCheckIfExists *mStorageMockCheckIfExists) Set(f func(orderID int64) (err error)) *StorageMock {
	if mmCheckIfExists.defaultExpectation != nil {
		mmCheckIfExists.mock.t.Fatalf("Default expectation is already set for the Storage.CheckIfExists method")
	}

	if len(mmCheckIfExists.expectations) > 0 {
		mmCheckIfExists.mock.t.Fatalf("Some expectations are already set for the Storage.CheckIfExists method")
	}

	mmCheckIfExists.mock.funcCheckIfExists = f
	mmCheckIfExists.mock.funcCheckIfExistsOrigin = minimock.CallerInfo(1)
	return mmCheckIfExists.mock
}

// When sets expectation for the Storage.CheckIfExists which will trigger the result defined by the following
// Then helper
func (mmCheckIfExists *mStorageMockCheckIfExists) When(orderID int64) *StorageMockCheckIfExistsExpectation {
	if mmCheckIfExists.mock.funcCheckIfExists != nil {
		mmCheckIfExists.mock.t.Fatalf("StorageMock.CheckIfExists mock is already set by Set")
	}

	expectation := &StorageMockCheckIfExistsExpectation{
		mock:               mmCheckIfExists.mock,
		params:             &StorageMockCheckIfExistsParams{orderID},
		expectationOrigins: StorageMockCheckIfExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckIfExists.expectations = append(mmCheckIfExists.expectations, expectation)
	return expectation
}

// Then sets up Storage.CheckIfExists return parameters for the expectation previously defined by the When method
func (e *StorageMockCheckIfExistsExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockCheckIfExistsResults{err}
	return e.mock
}

// Times sets number of times Storage.CheckIfExists should be invoked
func (mmCheckIfExists *mStorageMockCheckIfExists) Times(n uint64) *mStorageMockCheckIfExists {
	if n == 0 {
		mmCheckIfExists.mock.t.Fatalf("Times of StorageMock.CheckIfExists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckIfExists.expectedInvocations, n)
	mmCheckIfExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckIfExists
}

func (mmCheckIfExists *mStorageMockCheckIfExists) invocationsDone() bool {
	if len(mmCheckIfExists.expectations) == 0 && mmCheckIfExists.defaultExpectation == nil && mmCheckIfExists.mock.funcCheckIfExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckIfExists.mock.afterCheckIfExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckIfExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckIfExists implements mm_commands.Storage
func (mmCheckIfExists *StorageMock) CheckIfExists(orderID int64) (err error) {
	mm_atomic.AddUint64(&mmCheckIfExists.beforeCheckIfExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckIfExists.afterCheckIfExistsCounter, 1)

	mmCheckIfExists.t.Helper()

	if mmCheckIfExists.inspectFuncCheckIfExists != nil {
		mmCheckIfExists.inspectFuncCheckIfExists(orderID)
	}

	mm_params := StorageMockCheckIfExistsParams{orderID}

	// Record call args
	mmCheckIfExists.CheckIfExistsMock.mutex.Lock()
	mmCheckIfExists.CheckIfExistsMock.callArgs = append(mmCheckIfExists.CheckIfExistsMock.callArgs, &mm_params)
	mmCheckIfExists.CheckIfExistsMock.mutex.Unlock()

	for _, e := range mmCheckIfExists.CheckIfExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckIfExists.CheckIfExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckIfExists.CheckIfExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckIfExists.CheckIfExistsMock.defaultExpectation.params
		mm_want_ptrs := mmCheckIfExists.CheckIfExistsMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCheckIfExistsParams{orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmCheckIfExists.t.Errorf("StorageMock.CheckIfExists got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckIfExists.CheckIfExistsMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckIfExists.t.Errorf("StorageMock.CheckIfExists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckIfExists.CheckIfExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckIfExists.CheckIfExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckIfExists.t.Fatal("No results are set for the StorageMock.CheckIfExists")
		}
		return (*mm_results).err
	}
	if mmCheckIfExists.funcCheckIfExists != nil {
		return mmCheckIfExists.funcCheckIfExists(orderID)
	}
	mmCheckIfExists.t.Fatalf("Unexpected call to StorageMock.CheckIfExists. %v", orderID)
	return
}

// CheckIfExistsAfterCounter returns a count of finished StorageMock.CheckIfExists invocations
func (mmCheckIfExists *StorageMock) CheckIfExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckIfExists.afterCheckIfExistsCounter)
}

// CheckIfExistsBeforeCounter returns a count of StorageMock.CheckIfExists invocations
func (mmCheckIfExists *StorageMock) CheckIfExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckIfExists.beforeCheckIfExistsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CheckIfExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckIfExists *mStorageMockCheckIfExists) Calls() []*StorageMockCheckIfExistsParams {
	mmCheckIfExists.mutex.RLock()

	argCopy := make([]*StorageMockCheckIfExistsParams, len(mmCheckIfExists.callArgs))
	copy(argCopy, mmCheckIfExists.callArgs)

	mmCheckIfExists.mutex.RUnlock()

	return argCopy
}

// MinimockCheckIfExistsDone returns true if the count of the CheckIfExists invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCheckIfExistsDone() bool {
	if m.CheckIfExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckIfExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckIfExistsMock.invocationsDone()
}

// MinimockCheckIfExistsInspect logs each unmet expectation
func (m *StorageMock) MinimockCheckIfExistsInspect() {
	for _, e := range m.CheckIfExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CheckIfExists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckIfExistsCounter := mm_atomic.LoadUint64(&m.afterCheckIfExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckIfExistsMock.defaultExpectation != nil && afterCheckIfExistsCounter < 1 {
		if m.CheckIfExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.CheckIfExists at\n%s", m.CheckIfExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.CheckIfExists at\n%s with params: %#v", m.CheckIfExistsMock.defaultExpectation.expectationOrigins.origin, *m.CheckIfExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckIfExists != nil && afterCheckIfExistsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.CheckIfExists at\n%s", m.funcCheckIfExistsOrigin)
	}

	if !m.CheckIfExistsMock.invocationsDone() && afterCheckIfExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.CheckIfExists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckIfExistsMock.expectedInvocations), m.CheckIfExistsMock.expectedInvocationsOrigin, afterCheckIfExistsCounter)
	}
}

type mStorageMockDeleteOrderByID struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockDeleteOrderByIDExpectation
	expectations       []*StorageMockDeleteOrderByIDExpectation

	callArgs []*StorageMockDeleteOrderByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockDeleteOrderByIDExpectation specifies expectation struct of the Storage.DeleteOrderByID
type StorageMockDeleteOrderByIDExpectation struct {
	mock               *StorageMock
	params             *StorageMockDeleteOrderByIDParams
	paramPtrs          *StorageMockDeleteOrderByIDParamPtrs
	expectationOrigins StorageMockDeleteOrderByIDExpectationOrigins
	results            *StorageMockDeleteOrderByIDResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockDeleteOrderByIDParams contains parameters of the Storage.DeleteOrderByID
type StorageMockDeleteOrderByIDParams struct {
	i1 int64
}

// StorageMockDeleteOrderByIDParamPtrs contains pointers to parameters of the Storage.DeleteOrderByID
type StorageMockDeleteOrderByIDParamPtrs struct {
	i1 *int64
}

// StorageMockDeleteOrderByIDResults contains results of the Storage.DeleteOrderByID
type StorageMockDeleteOrderByIDResults struct {
	err error
}

// StorageMockDeleteOrderByIDOrigins contains origins of expectations of the Storage.DeleteOrderByID
type StorageMockDeleteOrderByIDExpectationOrigins struct {
	origin   string
	originI1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrderByID *mStorageMockDeleteOrderByID) Optional() *mStorageMockDeleteOrderByID {
	mmDeleteOrderByID.optional = true
	return mmDeleteOrderByID
}

// Expect sets up expected params for Storage.DeleteOrderByID
func (mmDeleteOrderByID *mStorageMockDeleteOrderByID) Expect(i1 int64) *mStorageMockDeleteOrderByID {
	if mmDeleteOrderByID.mock.funcDeleteOrderByID != nil {
		mmDeleteOrderByID.mock.t.Fatalf("StorageMock.DeleteOrderByID mock is already set by Set")
	}

	if mmDeleteOrderByID.defaultExpectation == nil {
		mmDeleteOrderByID.defaultExpectation = &StorageMockDeleteOrderByIDExpectation{}
	}

	if mmDeleteOrderByID.defaultExpectation.paramPtrs != nil {
		mmDeleteOrderByID.mock.t.Fatalf("StorageMock.DeleteOrderByID mock is already set by ExpectParams functions")
	}

	mmDeleteOrderByID.defaultExpectation.params = &StorageMockDeleteOrderByIDParams{i1}
	mmDeleteOrderByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteOrderByID.expectations {
		if minimock.Equal(e.params, mmDeleteOrderByID.defaultExpectation.params) {
			mmDeleteOrderByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrderByID.defaultExpectation.params)
		}
	}

	return mmDeleteOrderByID
}

// ExpectI1Param1 sets up expected param i1 for Storage.DeleteOrderByID
func (mmDeleteOrderByID *mStorageMockDeleteOrderByID) ExpectI1Param1(i1 int64) *mStorageMockDeleteOrderByID {
	if mmDeleteOrderByID.mock.funcDeleteOrderByID != nil {
		mmDeleteOrderByID.mock.t.Fatalf("StorageMock.DeleteOrderByID mock is already set by Set")
	}

	if mmDeleteOrderByID.defaultExpectation == nil {
		mmDeleteOrderByID.defaultExpectation = &StorageMockDeleteOrderByIDExpectation{}
	}

	if mmDeleteOrderByID.defaultExpectation.params != nil {
		mmDeleteOrderByID.mock.t.Fatalf("StorageMock.DeleteOrderByID mock is already set by Expect")
	}

	if mmDeleteOrderByID.defaultExpectation.paramPtrs == nil {
		mmDeleteOrderByID.defaultExpectation.paramPtrs = &StorageMockDeleteOrderByIDParamPtrs{}
	}
	mmDeleteOrderByID.defaultExpectation.paramPtrs.i1 = &i1
	mmDeleteOrderByID.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmDeleteOrderByID
}

// Inspect accepts an inspector function that has same arguments as the Storage.DeleteOrderByID
func (mmDeleteOrderByID *mStorageMockDeleteOrderByID) Inspect(f func(i1 int64)) *mStorageMockDeleteOrderByID {
	if mmDeleteOrderByID.mock.inspectFuncDeleteOrderByID != nil {
		mmDeleteOrderByID.mock.t.Fatalf("Inspect function is already set for StorageMock.DeleteOrderByID")
	}

	mmDeleteOrderByID.mock.inspectFuncDeleteOrderByID = f

	return mmDeleteOrderByID
}

// Return sets up results that will be returned by Storage.DeleteOrderByID
func (mmDeleteOrderByID *mStorageMockDeleteOrderByID) Return(err error) *StorageMock {
	if mmDeleteOrderByID.mock.funcDeleteOrderByID != nil {
		mmDeleteOrderByID.mock.t.Fatalf("StorageMock.DeleteOrderByID mock is already set by Set")
	}

	if mmDeleteOrderByID.defaultExpectation == nil {
		mmDeleteOrderByID.defaultExpectation = &StorageMockDeleteOrderByIDExpectation{mock: mmDeleteOrderByID.mock}
	}
	mmDeleteOrderByID.defaultExpectation.results = &StorageMockDeleteOrderByIDResults{err}
	mmDeleteOrderByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteOrderByID.mock
}

// Set uses given function f to mock the Storage.DeleteOrderByID method
func (mmDeleteOrderByID *mStorageMockDeleteOrderByID) Set(f func(i1 int64) (err error)) *StorageMock {
	if mmDeleteOrderByID.defaultExpectation != nil {
		mmDeleteOrderByID.mock.t.Fatalf("Default expectation is already set for the Storage.DeleteOrderByID method")
	}

	if len(mmDeleteOrderByID.expectations) > 0 {
		mmDeleteOrderByID.mock.t.Fatalf("Some expectations are already set for the Storage.DeleteOrderByID method")
	}

	mmDeleteOrderByID.mock.funcDeleteOrderByID = f
	mmDeleteOrderByID.mock.funcDeleteOrderByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteOrderByID.mock
}

// When sets expectation for the Storage.DeleteOrderByID which will trigger the result defined by the following
// Then helper
func (mmDeleteOrderByID *mStorageMockDeleteOrderByID) When(i1 int64) *StorageMockDeleteOrderByIDExpectation {
	if mmDeleteOrderByID.mock.funcDeleteOrderByID != nil {
		mmDeleteOrderByID.mock.t.Fatalf("StorageMock.DeleteOrderByID mock is already set by Set")
	}

	expectation := &StorageMockDeleteOrderByIDExpectation{
		mock:               mmDeleteOrderByID.mock,
		params:             &StorageMockDeleteOrderByIDParams{i1},
		expectationOrigins: StorageMockDeleteOrderByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteOrderByID.expectations = append(mmDeleteOrderByID.expectations, expectation)
	return expectation
}

// Then sets up Storage.DeleteOrderByID return parameters for the expectation previously defined by the When method
func (e *StorageMockDeleteOrderByIDExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockDeleteOrderByIDResults{err}
	return e.mock
}

// Times sets number of times Storage.DeleteOrderByID should be invoked
func (mmDeleteOrderByID *mStorageMockDeleteOrderByID) Times(n uint64) *mStorageMockDeleteOrderByID {
	if n == 0 {
		mmDeleteOrderByID.mock.t.Fatalf("Times of StorageMock.DeleteOrderByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOrderByID.expectedInvocations, n)
	mmDeleteOrderByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteOrderByID
}

func (mmDeleteOrderByID *mStorageMockDeleteOrderByID) invocationsDone() bool {
	if len(mmDeleteOrderByID.expectations) == 0 && mmDeleteOrderByID.defaultExpectation == nil && mmDeleteOrderByID.mock.funcDeleteOrderByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOrderByID.mock.afterDeleteOrderByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOrderByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOrderByID implements mm_commands.Storage
func (mmDeleteOrderByID *StorageMock) DeleteOrderByID(i1 int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrderByID.beforeDeleteOrderByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrderByID.afterDeleteOrderByIDCounter, 1)

	mmDeleteOrderByID.t.Helper()

	if mmDeleteOrderByID.inspectFuncDeleteOrderByID != nil {
		mmDeleteOrderByID.inspectFuncDeleteOrderByID(i1)
	}

	mm_params := StorageMockDeleteOrderByIDParams{i1}

	// Record call args
	mmDeleteOrderByID.DeleteOrderByIDMock.mutex.Lock()
	mmDeleteOrderByID.DeleteOrderByIDMock.callArgs = append(mmDeleteOrderByID.DeleteOrderByIDMock.callArgs, &mm_params)
	mmDeleteOrderByID.DeleteOrderByIDMock.mutex.Unlock()

	for _, e := range mmDeleteOrderByID.DeleteOrderByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrderByID.DeleteOrderByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrderByID.DeleteOrderByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrderByID.DeleteOrderByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOrderByID.DeleteOrderByIDMock.defaultExpectation.paramPtrs

		mm_got := StorageMockDeleteOrderByIDParams{i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmDeleteOrderByID.t.Errorf("StorageMock.DeleteOrderByID got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrderByID.DeleteOrderByIDMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrderByID.t.Errorf("StorageMock.DeleteOrderByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteOrderByID.DeleteOrderByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrderByID.DeleteOrderByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrderByID.t.Fatal("No results are set for the StorageMock.DeleteOrderByID")
		}
		return (*mm_results).err
	}
	if mmDeleteOrderByID.funcDeleteOrderByID != nil {
		return mmDeleteOrderByID.funcDeleteOrderByID(i1)
	}
	mmDeleteOrderByID.t.Fatalf("Unexpected call to StorageMock.DeleteOrderByID. %v", i1)
	return
}

// DeleteOrderByIDAfterCounter returns a count of finished StorageMock.DeleteOrderByID invocations
func (mmDeleteOrderByID *StorageMock) DeleteOrderByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrderByID.afterDeleteOrderByIDCounter)
}

// DeleteOrderByIDBeforeCounter returns a count of StorageMock.DeleteOrderByID invocations
func (mmDeleteOrderByID *StorageMock) DeleteOrderByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrderByID.beforeDeleteOrderByIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.DeleteOrderByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrderByID *mStorageMockDeleteOrderByID) Calls() []*StorageMockDeleteOrderByIDParams {
	mmDeleteOrderByID.mutex.RLock()

	argCopy := make([]*StorageMockDeleteOrderByIDParams, len(mmDeleteOrderByID.callArgs))
	copy(argCopy, mmDeleteOrderByID.callArgs)

	mmDeleteOrderByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderByIDDone returns true if the count of the DeleteOrderByID invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockDeleteOrderByIDDone() bool {
	if m.DeleteOrderByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOrderByIDMock.invocationsDone()
}

// MinimockDeleteOrderByIDInspect logs each unmet expectation
func (m *StorageMock) MinimockDeleteOrderByIDInspect() {
	for _, e := range m.DeleteOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.DeleteOrderByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteOrderByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteOrderByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderByIDMock.defaultExpectation != nil && afterDeleteOrderByIDCounter < 1 {
		if m.DeleteOrderByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.DeleteOrderByID at\n%s", m.DeleteOrderByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.DeleteOrderByID at\n%s with params: %#v", m.DeleteOrderByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOrderByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrderByID != nil && afterDeleteOrderByIDCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.DeleteOrderByID at\n%s", m.funcDeleteOrderByIDOrigin)
	}

	if !m.DeleteOrderByIDMock.invocationsDone() && afterDeleteOrderByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.DeleteOrderByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOrderByIDMock.expectedInvocations), m.DeleteOrderByIDMock.expectedInvocationsOrigin, afterDeleteOrderByIDCounter)
	}
}

type mStorageMockGetAll struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetAllExpectation
	expectations       []*StorageMockGetAllExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetAllExpectation specifies expectation struct of the Storage.GetAll
type StorageMockGetAllExpectation struct {
	mock *StorageMock

	results      *StorageMockGetAllResults
	returnOrigin string
	Counter      uint64
}

// StorageMockGetAllResults contains results of the Storage.GetAll
type StorageMockGetAllResults struct {
	m1  map[int64]*json_file.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAll *mStorageMockGetAll) Optional() *mStorageMockGetAll {
	mmGetAll.optional = true
	return mmGetAll
}

// Expect sets up expected params for Storage.GetAll
func (mmGetAll *mStorageMockGetAll) Expect() *mStorageMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("StorageMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &StorageMockGetAllExpectation{}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetAll
func (mmGetAll *mStorageMockGetAll) Inspect(f func()) *mStorageMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for StorageMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by Storage.GetAll
func (mmGetAll *mStorageMockGetAll) Return(m1 map[int64]*json_file.Order, err error) *StorageMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("StorageMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &StorageMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &StorageMockGetAllResults{m1, err}
	mmGetAll.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAll.mock
}

// Set uses given function f to mock the Storage.GetAll method
func (mmGetAll *mStorageMockGetAll) Set(f func() (m1 map[int64]*json_file.Order, err error)) *StorageMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the Storage.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the Storage.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	mmGetAll.mock.funcGetAllOrigin = minimock.CallerInfo(1)
	return mmGetAll.mock
}

// Times sets number of times Storage.GetAll should be invoked
func (mmGetAll *mStorageMockGetAll) Times(n uint64) *mStorageMockGetAll {
	if n == 0 {
		mmGetAll.mock.t.Fatalf("Times of StorageMock.GetAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAll.expectedInvocations, n)
	mmGetAll.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAll
}

func (mmGetAll *mStorageMockGetAll) invocationsDone() bool {
	if len(mmGetAll.expectations) == 0 && mmGetAll.defaultExpectation == nil && mmGetAll.mock.funcGetAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAll.mock.afterGetAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAll implements mm_commands.Storage
func (mmGetAll *StorageMock) GetAll() (m1 map[int64]*json_file.Order, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	mmGetAll.t.Helper()

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll()
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the StorageMock.GetAll")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll()
	}
	mmGetAll.t.Fatalf("Unexpected call to StorageMock.GetAll.")
	return
}

// GetAllAfterCounter returns a count of finished StorageMock.GetAll invocations
func (mmGetAll *StorageMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of StorageMock.GetAll invocations
func (mmGetAll *StorageMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetAllDone() bool {
	if m.GetAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllMock.invocationsDone()
}

// MinimockGetAllInspect logs each unmet expectation
func (m *StorageMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.GetAll")
		}
	}

	afterGetAllCounter := mm_atomic.LoadUint64(&m.afterGetAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && afterGetAllCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetAll at\n%s", m.GetAllMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && afterGetAllCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetAll at\n%s", m.funcGetAllOrigin)
	}

	if !m.GetAllMock.invocationsDone() && afterGetAllCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetAll at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllMock.expectedInvocations), m.GetAllMock.expectedInvocationsOrigin, afterGetAllCounter)
	}
}

type mStorageMockGiveOrdersToClient struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGiveOrdersToClientExpectation
	expectations       []*StorageMockGiveOrdersToClientExpectation

	callArgs []*StorageMockGiveOrdersToClientParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGiveOrdersToClientExpectation specifies expectation struct of the Storage.GiveOrdersToClient
type StorageMockGiveOrdersToClientExpectation struct {
	mock               *StorageMock
	params             *StorageMockGiveOrdersToClientParams
	paramPtrs          *StorageMockGiveOrdersToClientParamPtrs
	expectationOrigins StorageMockGiveOrdersToClientExpectationOrigins
	results            *StorageMockGiveOrdersToClientResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGiveOrdersToClientParams contains parameters of the Storage.GiveOrdersToClient
type StorageMockGiveOrdersToClientParams struct {
	skuIDs []int64
}

// StorageMockGiveOrdersToClientParamPtrs contains pointers to parameters of the Storage.GiveOrdersToClient
type StorageMockGiveOrdersToClientParamPtrs struct {
	skuIDs *[]int64
}

// StorageMockGiveOrdersToClientResults contains results of the Storage.GiveOrdersToClient
type StorageMockGiveOrdersToClientResults struct {
	err error
}

// StorageMockGiveOrdersToClientOrigins contains origins of expectations of the Storage.GiveOrdersToClient
type StorageMockGiveOrdersToClientExpectationOrigins struct {
	origin       string
	originSkuIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGiveOrdersToClient *mStorageMockGiveOrdersToClient) Optional() *mStorageMockGiveOrdersToClient {
	mmGiveOrdersToClient.optional = true
	return mmGiveOrdersToClient
}

// Expect sets up expected params for Storage.GiveOrdersToClient
func (mmGiveOrdersToClient *mStorageMockGiveOrdersToClient) Expect(skuIDs []int64) *mStorageMockGiveOrdersToClient {
	if mmGiveOrdersToClient.mock.funcGiveOrdersToClient != nil {
		mmGiveOrdersToClient.mock.t.Fatalf("StorageMock.GiveOrdersToClient mock is already set by Set")
	}

	if mmGiveOrdersToClient.defaultExpectation == nil {
		mmGiveOrdersToClient.defaultExpectation = &StorageMockGiveOrdersToClientExpectation{}
	}

	if mmGiveOrdersToClient.defaultExpectation.paramPtrs != nil {
		mmGiveOrdersToClient.mock.t.Fatalf("StorageMock.GiveOrdersToClient mock is already set by ExpectParams functions")
	}

	mmGiveOrdersToClient.defaultExpectation.params = &StorageMockGiveOrdersToClientParams{skuIDs}
	mmGiveOrdersToClient.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGiveOrdersToClient.expectations {
		if minimock.Equal(e.params, mmGiveOrdersToClient.defaultExpectation.params) {
			mmGiveOrdersToClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGiveOrdersToClient.defaultExpectation.params)
		}
	}

	return mmGiveOrdersToClient
}

// ExpectSkuIDsParam1 sets up expected param skuIDs for Storage.GiveOrdersToClient
func (mmGiveOrdersToClient *mStorageMockGiveOrdersToClient) ExpectSkuIDsParam1(skuIDs []int64) *mStorageMockGiveOrdersToClient {
	if mmGiveOrdersToClient.mock.funcGiveOrdersToClient != nil {
		mmGiveOrdersToClient.mock.t.Fatalf("StorageMock.GiveOrdersToClient mock is already set by Set")
	}

	if mmGiveOrdersToClient.defaultExpectation == nil {
		mmGiveOrdersToClient.defaultExpectation = &StorageMockGiveOrdersToClientExpectation{}
	}

	if mmGiveOrdersToClient.defaultExpectation.params != nil {
		mmGiveOrdersToClient.mock.t.Fatalf("StorageMock.GiveOrdersToClient mock is already set by Expect")
	}

	if mmGiveOrdersToClient.defaultExpectation.paramPtrs == nil {
		mmGiveOrdersToClient.defaultExpectation.paramPtrs = &StorageMockGiveOrdersToClientParamPtrs{}
	}
	mmGiveOrdersToClient.defaultExpectation.paramPtrs.skuIDs = &skuIDs
	mmGiveOrdersToClient.defaultExpectation.expectationOrigins.originSkuIDs = minimock.CallerInfo(1)

	return mmGiveOrdersToClient
}

// Inspect accepts an inspector function that has same arguments as the Storage.GiveOrdersToClient
func (mmGiveOrdersToClient *mStorageMockGiveOrdersToClient) Inspect(f func(skuIDs []int64)) *mStorageMockGiveOrdersToClient {
	if mmGiveOrdersToClient.mock.inspectFuncGiveOrdersToClient != nil {
		mmGiveOrdersToClient.mock.t.Fatalf("Inspect function is already set for StorageMock.GiveOrdersToClient")
	}

	mmGiveOrdersToClient.mock.inspectFuncGiveOrdersToClient = f

	return mmGiveOrdersToClient
}

// Return sets up results that will be returned by Storage.GiveOrdersToClient
func (mmGiveOrdersToClient *mStorageMockGiveOrdersToClient) Return(err error) *StorageMock {
	if mmGiveOrdersToClient.mock.funcGiveOrdersToClient != nil {
		mmGiveOrdersToClient.mock.t.Fatalf("StorageMock.GiveOrdersToClient mock is already set by Set")
	}

	if mmGiveOrdersToClient.defaultExpectation == nil {
		mmGiveOrdersToClient.defaultExpectation = &StorageMockGiveOrdersToClientExpectation{mock: mmGiveOrdersToClient.mock}
	}
	mmGiveOrdersToClient.defaultExpectation.results = &StorageMockGiveOrdersToClientResults{err}
	mmGiveOrdersToClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGiveOrdersToClient.mock
}

// Set uses given function f to mock the Storage.GiveOrdersToClient method
func (mmGiveOrdersToClient *mStorageMockGiveOrdersToClient) Set(f func(skuIDs []int64) (err error)) *StorageMock {
	if mmGiveOrdersToClient.defaultExpectation != nil {
		mmGiveOrdersToClient.mock.t.Fatalf("Default expectation is already set for the Storage.GiveOrdersToClient method")
	}

	if len(mmGiveOrdersToClient.expectations) > 0 {
		mmGiveOrdersToClient.mock.t.Fatalf("Some expectations are already set for the Storage.GiveOrdersToClient method")
	}

	mmGiveOrdersToClient.mock.funcGiveOrdersToClient = f
	mmGiveOrdersToClient.mock.funcGiveOrdersToClientOrigin = minimock.CallerInfo(1)
	return mmGiveOrdersToClient.mock
}

// When sets expectation for the Storage.GiveOrdersToClient which will trigger the result defined by the following
// Then helper
func (mmGiveOrdersToClient *mStorageMockGiveOrdersToClient) When(skuIDs []int64) *StorageMockGiveOrdersToClientExpectation {
	if mmGiveOrdersToClient.mock.funcGiveOrdersToClient != nil {
		mmGiveOrdersToClient.mock.t.Fatalf("StorageMock.GiveOrdersToClient mock is already set by Set")
	}

	expectation := &StorageMockGiveOrdersToClientExpectation{
		mock:               mmGiveOrdersToClient.mock,
		params:             &StorageMockGiveOrdersToClientParams{skuIDs},
		expectationOrigins: StorageMockGiveOrdersToClientExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGiveOrdersToClient.expectations = append(mmGiveOrdersToClient.expectations, expectation)
	return expectation
}

// Then sets up Storage.GiveOrdersToClient return parameters for the expectation previously defined by the When method
func (e *StorageMockGiveOrdersToClientExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockGiveOrdersToClientResults{err}
	return e.mock
}

// Times sets number of times Storage.GiveOrdersToClient should be invoked
func (mmGiveOrdersToClient *mStorageMockGiveOrdersToClient) Times(n uint64) *mStorageMockGiveOrdersToClient {
	if n == 0 {
		mmGiveOrdersToClient.mock.t.Fatalf("Times of StorageMock.GiveOrdersToClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGiveOrdersToClient.expectedInvocations, n)
	mmGiveOrdersToClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGiveOrdersToClient
}

func (mmGiveOrdersToClient *mStorageMockGiveOrdersToClient) invocationsDone() bool {
	if len(mmGiveOrdersToClient.expectations) == 0 && mmGiveOrdersToClient.defaultExpectation == nil && mmGiveOrdersToClient.mock.funcGiveOrdersToClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGiveOrdersToClient.mock.afterGiveOrdersToClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGiveOrdersToClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GiveOrdersToClient implements mm_commands.Storage
func (mmGiveOrdersToClient *StorageMock) GiveOrdersToClient(skuIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmGiveOrdersToClient.beforeGiveOrdersToClientCounter, 1)
	defer mm_atomic.AddUint64(&mmGiveOrdersToClient.afterGiveOrdersToClientCounter, 1)

	mmGiveOrdersToClient.t.Helper()

	if mmGiveOrdersToClient.inspectFuncGiveOrdersToClient != nil {
		mmGiveOrdersToClient.inspectFuncGiveOrdersToClient(skuIDs)
	}

	mm_params := StorageMockGiveOrdersToClientParams{skuIDs}

	// Record call args
	mmGiveOrdersToClient.GiveOrdersToClientMock.mutex.Lock()
	mmGiveOrdersToClient.GiveOrdersToClientMock.callArgs = append(mmGiveOrdersToClient.GiveOrdersToClientMock.callArgs, &mm_params)
	mmGiveOrdersToClient.GiveOrdersToClientMock.mutex.Unlock()

	for _, e := range mmGiveOrdersToClient.GiveOrdersToClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGiveOrdersToClient.GiveOrdersToClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGiveOrdersToClient.GiveOrdersToClientMock.defaultExpectation.Counter, 1)
		mm_want := mmGiveOrdersToClient.GiveOrdersToClientMock.defaultExpectation.params
		mm_want_ptrs := mmGiveOrdersToClient.GiveOrdersToClientMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGiveOrdersToClientParams{skuIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.skuIDs != nil && !minimock.Equal(*mm_want_ptrs.skuIDs, mm_got.skuIDs) {
				mmGiveOrdersToClient.t.Errorf("StorageMock.GiveOrdersToClient got unexpected parameter skuIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGiveOrdersToClient.GiveOrdersToClientMock.defaultExpectation.expectationOrigins.originSkuIDs, *mm_want_ptrs.skuIDs, mm_got.skuIDs, minimock.Diff(*mm_want_ptrs.skuIDs, mm_got.skuIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGiveOrdersToClient.t.Errorf("StorageMock.GiveOrdersToClient got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGiveOrdersToClient.GiveOrdersToClientMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGiveOrdersToClient.GiveOrdersToClientMock.defaultExpectation.results
		if mm_results == nil {
			mmGiveOrdersToClient.t.Fatal("No results are set for the StorageMock.GiveOrdersToClient")
		}
		return (*mm_results).err
	}
	if mmGiveOrdersToClient.funcGiveOrdersToClient != nil {
		return mmGiveOrdersToClient.funcGiveOrdersToClient(skuIDs)
	}
	mmGiveOrdersToClient.t.Fatalf("Unexpected call to StorageMock.GiveOrdersToClient. %v", skuIDs)
	return
}

// GiveOrdersToClientAfterCounter returns a count of finished StorageMock.GiveOrdersToClient invocations
func (mmGiveOrdersToClient *StorageMock) GiveOrdersToClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOrdersToClient.afterGiveOrdersToClientCounter)
}

// GiveOrdersToClientBeforeCounter returns a count of StorageMock.GiveOrdersToClient invocations
func (mmGiveOrdersToClient *StorageMock) GiveOrdersToClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOrdersToClient.beforeGiveOrdersToClientCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GiveOrdersToClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGiveOrdersToClient *mStorageMockGiveOrdersToClient) Calls() []*StorageMockGiveOrdersToClientParams {
	mmGiveOrdersToClient.mutex.RLock()

	argCopy := make([]*StorageMockGiveOrdersToClientParams, len(mmGiveOrdersToClient.callArgs))
	copy(argCopy, mmGiveOrdersToClient.callArgs)

	mmGiveOrdersToClient.mutex.RUnlock()

	return argCopy
}

// MinimockGiveOrdersToClientDone returns true if the count of the GiveOrdersToClient invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGiveOrdersToClientDone() bool {
	if m.GiveOrdersToClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GiveOrdersToClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GiveOrdersToClientMock.invocationsDone()
}

// MinimockGiveOrdersToClientInspect logs each unmet expectation
func (m *StorageMock) MinimockGiveOrdersToClientInspect() {
	for _, e := range m.GiveOrdersToClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GiveOrdersToClient at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGiveOrdersToClientCounter := mm_atomic.LoadUint64(&m.afterGiveOrdersToClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GiveOrdersToClientMock.defaultExpectation != nil && afterGiveOrdersToClientCounter < 1 {
		if m.GiveOrdersToClientMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GiveOrdersToClient at\n%s", m.GiveOrdersToClientMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GiveOrdersToClient at\n%s with params: %#v", m.GiveOrdersToClientMock.defaultExpectation.expectationOrigins.origin, *m.GiveOrdersToClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveOrdersToClient != nil && afterGiveOrdersToClientCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GiveOrdersToClient at\n%s", m.funcGiveOrdersToClientOrigin)
	}

	if !m.GiveOrdersToClientMock.invocationsDone() && afterGiveOrdersToClientCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GiveOrdersToClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GiveOrdersToClientMock.expectedInvocations), m.GiveOrdersToClientMock.expectedInvocationsOrigin, afterGiveOrdersToClientCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAcceptReturnInspect()

			m.MinimockAddOrderInspect()

			m.MinimockAddOrderToStoryInspect()

			m.MinimockCheckIfExistsInspect()

			m.MinimockDeleteOrderByIDInspect()

			m.MinimockGetAllInspect()

			m.MinimockGiveOrdersToClientInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcceptReturnDone() &&
		m.MinimockAddOrderDone() &&
		m.MinimockAddOrderToStoryDone() &&
		m.MinimockCheckIfExistsDone() &&
		m.MinimockDeleteOrderByIDDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockGiveOrdersToClientDone()
}
